%###############################################################
\section{Theory}\label{sec:Theory}
%###############################################################

This section explains how to design factories that build arbitrary 2D shaped polyominos.
 We first assign species to individual tiles of the polyomino, second discover a build path, and finally build an assembly line of factory components that each add one tile to partially assembled polyomino and pass the polyomino to the next component.


%###############################################################
\subsection{Arbitrary 2D shapes require two particle species}\label{subsec:RobotSpecies}
%###############################################################
A \emph{polyomino} is a 2D geometric figure formed by joining one or more equal squares edge to edge. Polyominoes have four-point connectivity.


\begin{lemma}
  Any polyomino can be constructed using just two species
  \end{lemma}
\begin{proof} 
Label a grid with an alternating pattern like a checkerboard.  Any desired polyomino can be constructed on this checkerboard, and all joints are between dissimilar species.
  An example shape is shown in Fig.~\ref{fig:Grid}.
  \end{proof}
  
  The sufficiency of two species to construct any shape gives many options for implementation.  The two species could correspond to any gendered connection, 
including electric charge, ionic charge, magnetic polarity, or hook-and-loop type fasteners.


   \begin{figure}
   \centering
\begin{overpic}[width =.3\columnwidth]{Grid.pdf}
\end{overpic}
\caption{\label{fig:Grid}Any polyomino can be constructed with two compatible robot species.  
}
\end{figure}


%###############################################################
\subsection{Complexity Handled in This Paper}\label{sec:ComplexityHandled}
%###############################################################

Different 2D part geometries are more difficult to construct than others.  Fig.~\ref{fig:IncreasingDifficulty} shows four parts of varying complexity. 
Label the first particle in the assembly process the seed particle. 
 The part on the left is shaped as a `\#' symbol.  Though it has an interior hole, any of the 16 particles could serve as the seed particle, and the shape could be constructed around it.  The second shape is a spiral, and must be constructed from the inside-out.  If the outer spiral was completed first, there would be no path to add particles to finish the interior because added particles would have to slide past compatible particles.  Increasing the number of species would not solve this problem, because there is a narrow passage through the spiral that forces incoming parts to slide past the edges of all the bonded particles.

The third shape is the combination of a left-handed and a right-handed spiral.
 This part cannot be assembled by adding one particle at a time, because each spiral must be constructed from the inside-out.  
 Instead, this part must be divided into sub-assemblies that are each constructed, and then combined.
The fourth shape contains compound overhangs, and may be impossible to construct with additive manufacturing.
 The algorithms in this paper detect if the desired shape can be constructed one particle at a time.  
 If so, a build order is provided, and a factory layout is designed.


   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{IncreasingDifficulty2.pdf}
\end{overpic}
\caption{\label{fig:IncreasingDifficulty}Polyomino parts. Difficulty increases from left to right. The right parts  cannot be built by additive construction. 
}
\end{figure} 

% A polyomino is said to be \emph{column convex} if each column has no holes. Similarly, a polyomino is said to be row convex if each row has no holes. A polyomino is said to be \emph{convex} if it is row and column convex.
%
%\begin{lemma}\label{lemma:convexonjectsCanbeConstructedAdditively}
%Any convex polyomino can be constructed by adding one particle at a time
%\end{lemma}
%\begin{proof}
%Select any pixel as the \emph{seed block}, or root node.  Perform a breadth-first search starting at the seed block, labelling each block in the order they are expanded.  Constructing the shape according to the ordering ensures that the polyomino is convex at every step of construction.
%\end{proof}

%The proof of \ref{lemma:convexonjectsCanbeConstructedAdditively} assumes the existence of fixtures for assembly.
%\todo{describe fixtures for adding one particle at a time}

%Some non-convex polynominos cannot be constructed one particle at a time, as illustrated in Fig. ~\ref{fig:IncreasingDifficulty}.    For instance, a polynomino consisting of a clockwise and a counterclockwise square spiral, joined at the ends with a gap of one unit between the spirals must be constructed by first assembling each spiral, and then combining the sub assemblies.




%###############################################################
\subsection{Discovering a Build Path}
%###############################################################

Given a polyomino, Alg.~\ref{alg:FindBuildPath} determines if the polyomino can be built by adding one component at a time.
 The forward problem of determining a build order is difficult because there are $O(n!)$ possible build orders, and many of them may be violate the constraints give in Section \label{subsc:model}.  
 Each new tile must have a straight-line path to its goal position in the polyomino that does not collide with any other particle, does not slide past an opposite species of tile, and terminates in a mating configuration with an opposite species tile.
As in many robotics problem, the inverse problem is easier.  
The inverse problem of deconstruction maintains an array of the remaining tiles in the polyomino $\mathbf{R}$. 
 In the inner for loop at line  \ref{alg:line:forloopTotryremovinEachTile}, a temporary array $\mathbf{T}$ is generated that contains all but the $j$th tile in $\mathbf{R}$.
This loop simply checks (1) if the $j$th tile can be removed along a straight-line path without  colliding with any other particle or sliding past an opposite species of tile in line \ref{alg:line:checkpathtile}, and (2) that its removal does not fragment the remaining polyomino into more than one piece in line \ref{alg:line:NumConnectedComp}. 
This algorithm requires at most  $1/2 n (1 + n)$ iterations, because there are $n$ particles to remove, and each iteration considers one less particle than the previous iteration.

\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\begin{algorithmic}[1]
%\scriptsize 
\caption{\sc {FindBuildPath}($\mathbf{P})$   \label{alg:FindBuildPath}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino that has at least a 1-tile empty border.
Returns $ \mathbf{C} $, $ \mathbf{c} $ and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates, $ \mathbf{c} $ is a vector of color labels and $\mathbf{m}$ is a vector of directions for assembly.
\begin{algorithmic}[1]

\State\hbox{$ \mathbf{c}\leftarrow${\sc{LabelColor}}($\mathbf{P}$)}
\State $\{\mathbf{C},\mathbf{m} \}= ${\sc {Decompose}}$(\mathbf{P},\mathbf{c})$
\State \Return $\{ \mathbf{C},\mathbf{c}, \mathbf{m} \} $ 
\end{algorithmic}
\end{algorithm} 



\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize 
\caption{\sc {Decompose}($\mathbf{P},\mathbf{c})$   \label{alg:FindBuildPath}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino and $ \mathbf{c} $ is a vector of color labels.
Returns $ \mathbf{C} $, and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates and $\mathbf{m}$ is a vector of directions for assembly.
\begin{algorithmic}[1]

\State $ \{ \mathbf{R},\mathbf{C}, \mathbf{m}, \ell \} \gets ${\sc {Erode}}$(\mathbf{P},\mathbf{c})$
\If {$|  \mathbf{R} | = 0 \textbf{ or } \neg \ell$}
\State \Return $\{ \mathbf{C},\mathbf{m} \}$ 
\EndIf

\State $\mathbf{d} \gets\{u,d,l,r\}, \mathbf{R} \gets \mathbf{P}$
\For{$j\leftarrow 1, j \le  |\mathbf{R}| $}
\State $\mathbf{p} \gets \mathbf{R}_j,  \mathbf{T} \gets  \mathbf{R}  \backslash   \mathbf{R}_j$

\For{$ k \leftarrow 1, k \le  4$   \label{alg:line:forloopTotryremovinEachTile} }
\If{{ ( \sc CheckPathTile}($\mathbf{T},\mathbf{p}, \mathbf{d}_k, \mathbf{c}$) \label{alg:line:checkpathtile} \textbf{and }
\\ \textbf{~~~~~~~~~~~~ }
$1 = |\text{\sc 4-ConnComp}(\mathbf{T})|$)  \label{alg:line:NumConnectedComp}}
\State $\{\mathbf{C2},\mathbf{m2} \}= ${\sc {Decompose}}$(\mathbf{T},\mathbf{c})$
\If {$\mathbf{C2}  \ne \{\}$}
\State  $\mathbf{C}_{ 1+|\mathbf{R}|} \gets \mathbf{p},  \mathbf{m}_{ |\mathbf{R}|}  \gets \mathbf{d}_k$
\State $\mathbf{C}_{1:|\mathbf{C2}|} \gets \mathbf{C2}, \mathbf{m}_{1:|\mathbf{m2}|} \gets \mathbf{m2}$
\State \Return $\{ \mathbf{C}, \mathbf{m} \}$ 
\EndIf
\State \textbf{break}
\EndIf
%\EndIf
\EndFor
\EndFor
\State $\mathbf{C} \gets \{\}, \mathbf{m} \gets \{\}$
\State \Return $\{ \mathbf{C}, \mathbf{m} \}$ 
\end{algorithmic}
\end{algorithm} 


\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize 
\caption{\sc {Erode}($\mathbf{P},\mathbf{c})$   \label{alg:FindBuildPath}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino  and $ \mathbf{c} $ is a vector of color labels.
Returns $ \mathbf{R} $, $ \mathbf{C} $, $\mathbf{m}$, and $\mathbf{\ell}$ where $ \mathbf{R} $  is a list of coordinates of the remaining polyomino, $ \mathbf{C} $ contains sequence of tile coordinates that were removed,   $\mathbf{m}$ is a vector of directions for assembly, and $\mathbf{\ell}$ if loops were detected.
\begin{algorithmic}[1]

\State\hbox{$\mathbf{C} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}, \mathbf{\ell} \gets \textrm{\sc False}$}
\State $\mathbf{d} \gets\{u,d,l,r\}, \mathbf{R} \gets \mathbf{P}$
\State $w \gets |\text{\sc 8-ConnComp}|(\neg\mathbf{R})$ 
\For{$i\leftarrow 1, i <  |\mathbf{P}| $}
\State  \emph{successRemove} $\gets$ {\sc False}
\For{$j\leftarrow 1, j \le  |\mathbf{R}| $}
\State $\mathbf{p} \gets \mathbf{R}_j,  \mathbf{T} \gets  \mathbf{R}  \backslash   \mathbf{R}_j$

\For{$ k \leftarrow 1, k \le  4$   \label{alg:line:forloopTotryremovinEachTile} }
\If{{\sc CheckPathTile}($\mathbf{T},\mathbf{p}, \mathbf{d}_k, \mathbf{c}$) \label{alg:line:checkpathtile} \textbf{and}
\\ \textbf{~~~~~~~~~~~~~~}
$1 = |\text{\sc 4-ConnComp}(\mathbf{T})|$  \label{alg:line:NumConnectedComp}}
\If{$w = |\text{\sc 8-ConnComp}(\neg\mathbf{T})|$  \label{alg:line:Num8ConnectedComp}}

\State  $\mathbf{R} \gets \mathbf{T}$,   \emph{successRemove} $\gets$ {\sc True}
\State  $\mathbf{C}_{ 1+|\mathbf{R}|} \gets \mathbf{p},  \mathbf{m}_{ |\mathbf{R}|}  \gets \mathbf{d}_k$
\Else { $  \mathbf{\ell} \gets \textrm{\sc True}$}
\EndIf
\State \textbf{break}
\EndIf
\EndFor
\EndFor
\If {  \emph{successRemove} $=$ {\sc False}}
\State  \hbox{$\mathbf{C} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}$}
\State \textbf{break}
\EndIf
\EndFor
\If {$ |\mathbf{R}| = 1$}
\State  $\mathbf{C}_{ 1} \gets \mathbf{R}_1 $
\EndIf
\State \Return $\{ \mathbf{R},\mathbf{C}, \mathbf{m}, \ell \}$ 
\end{algorithmic}
\end{algorithm} 


%\begin{algorithm}
%\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%%\scriptsize 
%\caption{\sc {FindBuildPath}($\mathbf{P})$   \label{alg:FindBuildPath}}
%$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino. 
%Returns $ \mathbf{C} $, $ \mathbf{c} $ and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates, $ \mathbf{c} $ is a vector of color labels and $\mathbf{m}$ is a vector of directions for assembly.
%\begin{algorithmic}[1]
%%\State$\mathbf{C} \leftarrow \{\}$,\State$ \mathbf{c} \leftarrow \{\}$, \State$ \mathbf{m} \leftarrow \{\}$
%\State\hbox{$\mathbf{C} \leftarrow \{\},\mathbf{c} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}$}
%\State$\mathbf{c}\leftarrow${\sc{LabelColor}}($\mathbf{P}$)
%\For{$m\leftarrow 1, m \le  |\mathbf{P}| )$}
%\State$\mathbf{C}\leftarrow${\sc{DepthFirstSearch}}($\mathbf{P}_m$,$\mathbf{P}$)
%\State$ \mathbf{m}\leftarrow${\sc{CheckPathTile}}($\mathbf{C}$, $\mathbf{c}$)
%\If{$ \{\} \ne \mathbf{m}$}
%\State \textbf{break}
%\EndIf
%\EndFor\\
%\Return $\{ \mathbf{C},\mathbf{c}, \mathbf{m} \}$ 
%\end{algorithmic}
%\end{algorithm} 
  
%###############################################################
\subsection{Assembling Tiles}
%###############################################################


%###############################################################
\subsubsection{Hopper Construction}\label{subsec:HopperConstruction}
%###############################################################
Two-part adhesives react when the components mix.  Placing the components in separate containers prevents mixing.  Similarly, storing many particles of a single species in separate containers allows controlled mixing.
%WIKI: harden by mixing two or more components which chemically react.

We can design \emph{part hoppers}, containers that store similarly labelled particles.  These particles will not bond with each other.  The hopper shown in Fig.~\ref{fig:HopperCW} releases one particle every cycle.
   \begin{figure}
   \centering
\begin{overpic}[width =80mm]{hopperdirections.pdf}
\end{overpic}
\caption{\label{fig:HopperCW}Hopper with delays. The hopper is filled with similarly-labelled robots that will not combine.  Every clockwise command sequence $\langle u,r,d,l \rangle$ releases one robot from the hopper.  %\textcolor{red}{replace with new hopper design}
}
\end{figure}





\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{24tilefactory.pdf}
\end{overpic}
\caption{\label{fig:24tilefactory}A twenty-four tile factory (full resolution -- zoom in for details).
}
\end{figure}







%###############################################################
\subsection{Part Assembly Jigs}\label{subsec:PartAssemblyJigs}
%###############################################################


%\todo{Sheryl, add the algorithmic environment for Build Factory}
\begin{algorithm} 
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize
\caption{ \sc{BuildFactory}($\mathbf{P}, n$)\label{alg:BuildFactory}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino.  $n$ is the number of parts desired. 
Returns a two dimensional array $ \mathbf{F} $ containing the factory obstacles and filled hoppers.
\begin{algorithmic}[1]
\State$\mathbf{F} \leftarrow \{\}$ \Comment{the factory obstacle array} 
\State$ \mathbf{b} \leftarrow \{\}$ \Comment{the part being built} 

\State \{$\mathbf{C},\mathbf{c}, \mathbf{m}$\} $  \leftarrow$ {\sc{FindBuildPath}}($\mathbf{P}$)
 \If{$ \{\} \ne \mathbf{m}$}
 \For{$i\leftarrow 1, i \le  |\mathbf{m}| )$}
\State$\{ \mathbf{A}, \mathbf{b} \}\leftarrow${\sc{FactoryAddTile}}$(n,\mathbf{b}, \mathbf{m}_i,\mathbf{C}_i, \mathbf{c}_i,w)$
\State$ \mathbf{F} \leftarrow${\sc{ConcatFactories}}$(\mathbf{F},\mathbf{A})$
\EndFor
 \EndIf 
\State \Return  $ \mathbf{F} $
%\State{\sc{DisplayFactory}}($factoryLayout$)
\end{algorithmic}
\end{algorithm} 
 
 
 

 
 
\begin{algorithm} 
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize
\caption{\sc {FactoryAddTile}$(n,\mathbf{b}, m,C, c,w)$ \label{alg:FactoryAddTile}}
\begin{algorithmic}[1]
\State$
\{ \mathbf{hopper}\}\leftarrow${\sc{Hopper}}$(c,n,w)$
\If{ $m = d \textbf{ and } \left(     C_y  \le \max \mathbf{b}_y   
                         \textbf{ or }  C_y     > \min \mathbf{b}_x \right)  }$
    
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{downdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = l \textbf{ and } \left(     C_x  \le \max \mathbf{b}_x   
                         \textbf{ or }  C_y     > \min \mathbf{b}_y \right)  }$
    
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{leftdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = u \textbf{ and } \left(     C_y  \le \min \mathbf{b}_y   
                        \textbf{ or }  C_x     > \min \mathbf{b}_x \right)  }$
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{updir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = r \textbf{ and } \left(     C_y  \le \min \mathbf{b}_x   
                        \textbf{ or }  C_y     > \min \mathbf{b}_y \right)  }$
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{rightdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\EndIf

\State \Return $\{ \mathbf{A}, \mathbf{b} \}$ 

\end{algorithmic}
\end{algorithm}
 
 
 
 
 
 

