%###############################################################
\section{Theory}\label{sec:Theory}
%###############################################################

This section explains how to design factories that build arbitrary-shaped 2D polyominoes.
 We first assign species to individual tiles of the polyomino, second discover a build path, and finally build an assembly line of factory components that each add one tile to partially assembled polyomino and pass the polyomino to the next component.


%###############################################################
\subsection{Arbitrary 2D shapes require two particle species}\label{subsec:RobotSpecies}
%###############################################################
A \emph{polyomino} is a 2D geometric figure formed by joining one or more equal squares edge to edge. Polyominoes have four-point connectivity.


\begin{lemma}
  Any polyomino can be constructed using just two species
  \end{lemma}
\begin{proof} 
Label a grid with an alternating pattern like a checkerboard.  Any desired polyomino can be constructed on this checkerboard, and all joints are between dissimilar species.
  An example shape is shown in Fig.~\ref{fig:Grid}.
  \end{proof}

   \begin{figure}
   \centering
\begin{overpic}[width =.8\columnwidth]{Grid2.pdf}
\end{overpic}
\caption{\label{fig:Grid}Any polyomino can be constructed with two compatible robot species.  
}
\end{figure}

  
  The sufficiency of two species to construct any shape gives many options for implementation.  The two species could correspond to any gendered connection, 
including electric charge, ionic charge, magnetic polarity, or hook-and-loop type fasteners.




%###############################################################
\subsection{Complexity Handled in This Paper}\label{sec:ComplexityHandled}
%###############################################################

Different 2D part geometries are more difficult to construct than others.  Fig.~\ref{fig:IncreasingDifficulty} shows parts with increasing  complexity. 

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{IncreasingDifficulty3.pdf}
\end{overpic}
\caption{\label{fig:IncreasingDifficulty}Polyomino parts. Difficulty increases from left to right. Parts 4 and 5 cannot be built by additive construction. 
}
\end{figure} 
Label the first particle in the assembly process the \emph{seed particle}. 
 Part 1 is shaped as a `\#' symbol.  Though it has an interior hole, any of the 16 particles could serve as the seed particle, and the shape could be constructed around it.  The second shape is a spiral, and must be constructed from the inside-out.  If the outer spiral was completed first, there would be no path to add particles to finish the interior because added particles would have to slide past compatible particles.  Increasing the number of species would not solve this problem, because there is a narrow passage through the spiral that forces incoming parts to slide past the edges of all the bonded particles.
The third shape is contains a loop, and the interior must be finished before the loop is closed.
Shape 4 is the combination of a left-handed and a right-handed spiral.
 This part cannot be assembled by adding one particle at a time, because each spiral must be constructed from the inside-out.  
 Instead, this part must be divided into sub-assemblies that are each constructed, and then combined.
 Shape 5 contains compound overhangs, and may be impossible to construct with additive manufacturing.
 The algorithms in this paper detect if the desired shape can be constructed one particle at a time.  
 If so, a build order is provided, and a factory layout is designed.


% A polyomino is said to be \emph{column convex} if each column has no holes. Similarly, a polyomino is said to be row convex if each row has no holes. A polyomino is said to be \emph{convex} if it is row and column convex.
%
%\begin{lemma}\label{lemma:convexonjectsCanbeConstructedAdditively}
%Any convex polyomino can be constructed by adding one particle at a time
%\end{lemma}
%\begin{proof}
%Select any pixel as the \emph{seed block}, or root node.  Perform a breadth-first search starting at the seed block, labelling each block in the order they are expanded.  Constructing the shape according to the ordering ensures that the polyomino is convex at every step of construction.
%\end{proof}

%The proof of \ref{lemma:convexonjectsCanbeConstructedAdditively} assumes the existence of fixtures for assembly.
%\todo{describe fixtures for adding one particle at a time}

%Some non-convex polynominos cannot be constructed one particle at a time, as illustrated in Fig. ~\ref{fig:IncreasingDifficulty}.    For instance, a polynomino consisting of a clockwise and a counterclockwise square spiral, joined at the ends with a gap of one unit between the spirals must be constructed by first assembling each spiral, and then combining the sub assemblies.




%###############################################################
\subsection{Discovering a Build Path}
%###############################################################

Given a polyomino, Alg.~\ref{alg:FindBuildPath} determines if the polyomino can be built by adding one component at a time.
 The  problem of determining a build order is difficult because there are $O(n!)$ possible build orders, and many of them may  violate the constraints given in Section \ref{subsec:model}.  
 Each new tile must have a straight-line path to its goal position in the polyomino that does not collide with any other particle, does not slide past an opposite species of tile, and terminates in a mating configuration with an opposite species tile.
However, as in many robotics problem, the inverse problem of deconstruction is easier than the forward problem of construction.  

\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\begin{algorithmic}[1]
%\scriptsize 
\caption{\sc {FindBuildPath}($\mathbf{P})$   \label{alg:FindBuildPath}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino. % that has at least a 1-tile empty border.
Returns $ \mathbf{C} $, $ \mathbf{c} $ and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates, $ \mathbf{c} $ is a vector of color labels, and $\mathbf{m}$ is a vector of directions for assembly.
\begin{algorithmic}[1]

\State\hbox{$ \mathbf{c}\leftarrow${\sc{LabelColor}}($\mathbf{P}$)}
\State $\{\mathbf{C},\mathbf{m} \}= ${\sc {Decompose}}$(\mathbf{P},\mathbf{c})$
\State \Return $\{ \mathbf{C},\mathbf{c}, \mathbf{m} \} $ 
\end{algorithmic}
\end{algorithm} 

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{DeconstructionOrderMattersSlide.pdf}
\end{overpic}
\caption{\label{fig:DeconstructionOrderMatters} Deconstruction order matters if loops are present.  Loops occur when the 8-connected freespace has more than one connected component.  In the top row, the green tile is removed first, resulting in a polyomino that cannot be decomposed. However, if the bottom right tile is removed first, deconstruction is possible.
}
\end{figure} 

Alg.~\ref{alg:FindBuildPath}  first assigns each tile in the polynomial a color, then calls the recursive function {\sc {Decompose}}, which returns either a build order of polyomino coordinates and the directions to build, or an empty list if the part cannot be constructed.  
{\sc {Decompose}} starts by calls the function {\sc {Erode}}.  {\sc {Erode}} first counts the number of components in the 8-connected freespace.  If there is more than one connected component, the polynomial contains loops.  
 {\sc {Erode}} maintains an array of the remaining tiles in the polyomino $\mathbf{R}$. 
 In the inner for loop at line  \ref{alg:line:forloopTotryremovinEachTileERODE}, a temporary array $\mathbf{T}$ is generated that contains all but the $j$th tile in $\mathbf{R}$.
This for loop simply checks (1) if the $j$th tile can be removed along a straight-line path without  colliding with any other particle or sliding past an opposite species of tile in line \ref{alg:line:checkpathtileERODE},  (2) that its removal does not fragment the remaining polyomino into more than one piece in line \ref{alg:line:NumConnectedCompERODE}, and (3) that its removal does not break a loop in line \ref{alg:line:Num8ConnectedCompERODE}. 
If no loops are present, this algorithm requires at most  $1/2 n (1 + n)$ iterations, because there are $n$ particles to remove, and each iteration considers one less particle than the previous iteration.

Polynomials with loops require care, because decomposing them in the wrong order can make disassembly impossible, as shown in Fig.~\ref{fig:DeconstructionOrderMatters}.
If loops exist then  {\sc {Erode}} may return only a partial decomposition, so {\sc {Decompose}} must then try every possible break point and recursively call {\sc {Decompose}} until either a solution is found, or all possible decomposition orders have been tested.  The worst-case number of function calls of  {\sc {Decompose}}  are proportional to the factorial of the number of loops, $O( |\text{\sc 8-ConnComp}(\neg\mathbf{P})| !)$. Though large, this is much less than $O(n!)$.

\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize 
\caption{\sc {Erode}($\mathbf{P},\mathbf{c})$   \label{alg:Erode}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino  and $ \mathbf{c} $ is a vector of color labels.
Returns $ \mathbf{R} $, $ \mathbf{C} $, $\mathbf{m}$, and $\mathbf{\ell}$ where $ \mathbf{R} $  is a list of coordinates of the remaining polyomino, $ \mathbf{C} $ contains sequence of tile coordinates that were removed,   $\mathbf{m}$ is a vector of directions for assembly, and $\mathbf{\ell}$ if loops were encountered.
\begin{algorithmic}[1]

\State\hbox{$\mathbf{C} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}, \mathbf{\ell} \gets \textrm{\sc False}$}
\State $\mathbf{d} \gets\{u,d,l,r\}, \mathbf{R} \gets \mathbf{P}$
\State $w \gets |\text{\sc 8-ConnComp}(\neg\mathbf{R})|$ 
\For{$i\leftarrow 1, i <  |\mathbf{P}| $}
\State  \emph{successRemove} $\gets$ {\sc False}
\For{$j\leftarrow 1, j \le  |\mathbf{R}| $}
\State $\mathbf{p} \gets \mathbf{R}_j,  \mathbf{T} \gets  \mathbf{R}  \backslash   \mathbf{R}_j$

\For{$ k \leftarrow 1, k \le  4$   \label{alg:line:forloopTotryremovinEachTileERODE} }
\If{{\sc CheckPathTile}($\mathbf{T},\mathbf{p}, \mathbf{d}_k, \mathbf{c}$) \label{alg:line:checkpathtileERODE} \textbf{and}
\\ \textbf{~~~~~~~~~~~~~~}
$1 = |\text{\sc 4-ConnComp}(\mathbf{T})|$  \label{alg:line:NumConnectedCompERODE}}
\If{$w = |\text{\sc 8-ConnComp}(\neg\mathbf{T})|$  \label{alg:line:Num8ConnectedCompERODE}}

\State  $\mathbf{R} \gets \mathbf{T}$,   \emph{successRemove} $\gets$ {\sc True}
\State  $\mathbf{C}_{ 1+|\mathbf{R}|} \gets \mathbf{p},  \mathbf{m}_{ |\mathbf{R}|}  \gets \mathbf{d}_k$
\Else { $  \mathbf{\ell} \gets \textrm{\sc True}$}
\EndIf
\State \textbf{break}
\EndIf
\EndFor
\EndFor
\If {  \emph{successRemove} $=$ {\sc False}}
\State  \hbox{$\mathbf{C} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}$}
\State \textbf{break}
\EndIf
\EndFor
\If {$ |\mathbf{R}| = 1$}
\State  $\mathbf{C}_{ 1} \gets \mathbf{R}_1 $
\EndIf
\State \Return $\{ \mathbf{R},\mathbf{C}, \mathbf{m}, \ell \}$ 
\end{algorithmic}
\end{algorithm} 









\begin{algorithm}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize 
\caption{\sc {Decompose}($\mathbf{P},\mathbf{c})$   \label{alg:Decompose}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino and $ \mathbf{c} $ is a vector of color labels.
Returns $ \mathbf{C} $ and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates and $\mathbf{m}$ is a vector of directions for assembly.
\begin{algorithmic}[1]

\State $ \{ \mathbf{R},\mathbf{C}, \mathbf{m}, \ell \} \gets ${\sc {Erode}}$(\mathbf{P},\mathbf{c})$
\If {$|  \mathbf{R} | = 0 \textbf{ or } \neg \ell$}
\State \Return $\{ \mathbf{C},\mathbf{m} \}$ 
\EndIf

\State $\mathbf{d} \gets\{u,d,l,r\}, \mathbf{R} \gets \mathbf{P}$
\For{$j\leftarrow 1, j \le  |\mathbf{R}| $}
\State $\mathbf{p} \gets \mathbf{R}_j,  \mathbf{T} \gets  \mathbf{R}  \backslash   \mathbf{R}_j$

\For{$ k \leftarrow 1, k \le  4$   \label{alg:line:forloopTotryremovinEachTileDecompose} }
\If{{ ( \sc CheckPathTile}($\mathbf{T},\mathbf{p}, \mathbf{d}_k, \mathbf{c}$) \label{alg:line:checkpathtileDecompose} \textbf{and }
\\ \textbf{~~~~~~~~~~~~ }
$1 = |\text{\sc 4-ConnComp}(\mathbf{T})|$)  \label{alg:line:NumConnectedCompDecompose}}
\State $\{\mathbf{C2},\mathbf{m2} \}\gets ${\sc {Decompose}}$(\mathbf{T},\mathbf{c})$
\If {$\mathbf{C2}  \ne \{\}$}
%\State  $\mathbf{C}_{ 1+|\mathbf{R}|} \gets \mathbf{p},  \mathbf{m}_{ |\mathbf{R}|}  \gets \mathbf{d}_k$
\State $\mathbf{C}_{1:|\mathbf{C2}|+1} \gets \{\mathbf{C2},\mathbf{p}\}$
\State $ \mathbf{m}_{1:|\mathbf{m2}|+1} \gets \{\mathbf{m2},\mathbf{d}_k\}$
\State \Return $\{ \mathbf{C}, \mathbf{m} \}$ 
\EndIf
\State \textbf{break}
\EndIf
%\EndIf
\EndFor
\EndFor
\State $\mathbf{C} \gets \{\}, \mathbf{m} \gets \{\}$
\State \Return $\{ \mathbf{C}, \mathbf{m} \}$ 
\end{algorithmic}
\end{algorithm} 



%\begin{algorithm}
%\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%%\scriptsize 
%\caption{\sc {FindBuildPath}($\mathbf{P})$   \label{alg:FindBuildPath}}
%$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino. 
%Returns $ \mathbf{C} $, $ \mathbf{c} $ and $\mathbf{m}$ where $ \mathbf{C} $ contains sequence of polyomino coordinates, $ \mathbf{c} $ is a vector of color labels and $\mathbf{m}$ is a vector of directions for assembly.
%\begin{algorithmic}[1]
%%\State$\mathbf{C} \leftarrow \{\}$,\State$ \mathbf{c} \leftarrow \{\}$, \State$ \mathbf{m} \leftarrow \{\}$
%\State\hbox{$\mathbf{C} \leftarrow \{\},\mathbf{c} \leftarrow \{\}, \mathbf{m} \leftarrow \{\}$}
%\State$\mathbf{c}\leftarrow${\sc{LabelColor}}($\mathbf{P}$)
%\For{$m\leftarrow 1, m \le  |\mathbf{P}| )$}
%\State$\mathbf{C}\leftarrow${\sc{DepthFirstSearch}}($\mathbf{P}_m$,$\mathbf{P}$)
%\State$ \mathbf{m}\leftarrow${\sc{CheckPathTile}}($\mathbf{C}$, $\mathbf{c}$)
%\If{$ \{\} \ne \mathbf{m}$}
%\State \textbf{break}
%\EndIf
%\EndFor\\
%\Return $\{ \mathbf{C},\mathbf{c}, \mathbf{m} \}$ 
%\end{algorithmic}
%\end{algorithm} 
  
%###############################################################
\subsection{Assembling Tiles}
%###############################################################


%###############################################################
\subsubsection{Hopper Construction}\label{subsec:HopperConstruction}
%###############################################################
Two-part adhesives react when the components mix.  Placing the components in separate containers prevents mixing.  Similarly, storing many particles of a single species in separate containers allows controlled mixing.
%WIKI: harden by mixing two or more components which chemically react.

We can design \emph{part hoppers}, containers that store similarly labelled particles.  These particles will not bond with each other.  The hopper shown in Fig.~\ref{fig:HopperCW} releases one particle every cycle. Delay blocks are used to ensure the $n$th part hopper does not start releasing particles until cycle $n$.

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{hopperdirections.pdf}
\end{overpic}
\caption{\label{fig:HopperCW}Hopper with delays. The hopper is filled with similarly-labelled robots that will not combine.  Every clockwise command sequence $\langle u,r,d,l \rangle$ releases one robot from the hopper.  %\textcolor{red}{replace with new hopper design}
}
\end{figure}





\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{24tilefactory.pdf}
\end{overpic}
\caption{\label{fig:24tilefactory}A twenty-four tile factory (full resolution -- zoom in for details).
}
\end{figure}







%###############################################################
\subsection{Part Assembly Jigs}\label{subsec:PartAssemblyJigs}
%###############################################################

Assembly is an iterative procedure.  
A factory layout is generated by  {\sc{BuildFactory}}($\mathbf{P}, n_c$), described in Alg.~\ref{alg:BuildFactory}. This function takes a 2D polyomino $\mathbf{P}$ and, if $\mathbf{P}$ has a valid build path, designs an obstacle layout to generate $n_c$ copies of the polyomino. A polyomino is composed of $|\mathbf{P}| = n$ tiles.  

For each tile, the function 
 {\sc{FactoryAddTile}} $(n_c,\mathbf{b}, m,C, c,w)$
  described in  Alg.~\ref{alg:FactoryAddTile}
is called to generates an obstacle configuration $\mathbf{A}$.
$\mathbf{A}$  forms a hopper that releases a particle each iteration and a chamber that temporarily holds the partially-assembled polyomino $\mathbf{b}$ and guides the new particle $C$ to the correct mating position. A 24-tile factory is shown in  Fig.~\ref{fig:24tilefactory}.


%\todo{Sheryl, add the algorithmic environment for Build Factory}
\begin{algorithm} 
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize
\caption{ \sc{BuildFactory}($\mathbf{P}, n_c$)\label{alg:BuildFactory}}
$\mathbf{P}$ is the $x,y$ coordinates of a 4-connected polyomino.  $n_c$ is the number of parts desired. 
Returns a two dimensional array $ \mathbf{F} $ containing the factory obstacles and filled hoppers.
\begin{algorithmic}[1]
\State$\mathbf{F} \leftarrow \{\}$ \Comment{the factory obstacle array} 
\State$ \mathbf{b} \leftarrow \{\}$ \Comment{the part being built} 

\State \{$\mathbf{C},\mathbf{c}, \mathbf{m}$\} $  \leftarrow$ {\sc{FindBuildPath}}($\mathbf{P}$)
 \If{$ \{\} = \mathbf{m}$}
 \State \Return  $ \mathbf{F} $
 \EndIf 
 \State$\{ \mathbf{A}, \mathbf{b} \}\leftarrow${\sc{FactoryFirstTile}}$(n_c, \mathbf{c}_i,w)$
 \For{$i\leftarrow 2, i \le  |\mathbf{c}| )$}
 \State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{FactoryAddTile}}$(n_c,\mathbf{b}, \mathbf{m}_{i-1},\mathbf{C}_i, \mathbf{c}_i,w)$
 \State$ \mathbf{F} \leftarrow${\sc{ConcatFactories}}$(\mathbf{F},\mathbf{A})$
\EndFor
\State \Return  $ \mathbf{F} $
%\State{\sc{DisplayFactory}}($factoryLayout$)
\end{algorithmic}
\end{algorithm} 
 
 
 

 
 
\begin{algorithm} 
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
%\scriptsize
\caption{\sc {FactoryAddTile}$(n_c,\mathbf{b}, m,C, c,w)$ \label{alg:FactoryAddTile}}
\begin{algorithmic}[1]
\State$
\{ \mathbf{hopper}\}\leftarrow${\sc{Hopper}}$(c,n_c,w)$
\If{ $m = d \textbf{ and } \left(     C_x  \le \max \mathbf{b}_x   
                         \textbf{ or }  C_y     < \min \mathbf{b}_y \right)  }$
    
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{downdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = l \textbf{ and} \left(     C_y  \le \max \mathbf{b}_y   
                         \textbf{ or }  C_x     > \max \mathbf{b}_x \right)  }$
    
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{leftdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = u \textbf{ and } \left(     C_y  > \max \mathbf{b}_y   
                        \textbf{ or }  C_x     >= \min \mathbf{b}_x \right)  }$
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{updir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\ElsIf{ $m = r \textbf{ and } \left(     C_x  < \min \mathbf{b}_x   
                        \textbf{ or }  C_y     >= \min \mathbf{b}_y \right)  }$
\State$\{\mathbf{A},\mathbf{b}\}\leftarrow${\sc{rightdir}}$(\mathbf{hopper},\mathbf{b},\mathbf{C})$

\EndIf

\State \Return $\{ \mathbf{A}, \mathbf{b} \}$ 

\end{algorithmic}
\end{algorithm}
 
 
 
 
 
 

