% easy truth tables: http://www.kwi.dk/projects/php/truthtable/?
%  177199 Hamed Mohtasham shad
% 177228 Rose Morris-Wright
%
% TODO: assembly (we can implement aTAM!) , 
% could we add tiny magnets to robot sides to make them link up?
% can we place our prototype  on an inclined lazy susan?
\pdfobjcompresslevel=0  % I had adobe error 131, and this removed it: http://tex.stackexchange.com/questions/64448/how-to-overcome-acrobat-reader-error-131-with-a-pdflatex-doc

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
\usepackage{calc}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
  colorlinks =true,
  urlcolor = black,
  linkcolor = black
}
\usepackage{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{rotating}
\usepackage{booktabs}

\usepackage{rotating}
\usepackage{nicefrac}
\usepackage{cite}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{overpic}
\graphicspath{{./pictures/pdf/},{./pictures/ps/},{./pictures/png/},{./pictures/jpg/}}
\usepackage{breqn} %for breaking equations automatically
\usepackage[ruled]{algorithm}
\usepackage{algpseudocode}
\usepackage{multirow}

\usepackage{bm}   % boldface math type
\usepackage{soul}  % for highlighting
\newcommand{\todo}[1]{\vspace{5 mm}\par \noindent \framebox{\begin{minipage}[c]{0.98 \columnwidth} \ttfamily\flushleft \textcolor{red}{#1}\end{minipage}}\vspace{5 mm}\par}
% uncomment this to hide all red todos
%\renewcommand{\todo}{}

%% ABBREVIATIONS
\newcommand{\figwid}{0.22\columnwidth}

\DeclareMathOperator{\atan2}{atan2}

\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\begin{document}

%%%%%%%%%%%%%% For debugging purposes, I like to display the TOC
%\tableofcontents
%\setcounter{tocdepth}{3}
%\newpage
%\mbox{}
%\newpage
%\mbox{}
%\newpage
%%%%%% END TOC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\LARGE \bf 
Parallel Assembly under Uniform Control Inputs 
}
\author{
Sheryl Manzoor,
%Erik D. Demaine,
%S\'andor P. Fekete,
Aaron T. Becker
\thanks{{
S.~Manzoor is with the  Dept.~of Electrical and Computer Engineering,  University of Houston, Houston, TX 70004, USA {\tt\small smanzoor2@uh.edu}.
%E.~Demaine is with the Computer Science and Artificial Intelligence Laboratory, MIT, Cambridge, MA 02139, USA,      \protect\url{edemaine@mit.edu},
%S.~Fekete is with the Dept.~of Computer Science, TU Braunschweig,  M\"uhlenpfordtstr.~23, 38106 Braunschweig, Germany,      \protect\url{s.fekete@tu-bs.de},
A.~Becker is with the  Dept.~of Electrical and Computer Engineering,  University of Houston, Houston, TX 70004, USA {\tt\small atbecker@uh.edu}.
}
} %\end thanks
} % end author block
\maketitle



\begin{abstract} 
We present fundamental progress on parallel assembly using large swarms of micro- or nano-scale robots
in complex environments, controlled not by individual navigation, but by a uniform global, external force.
Consider a 2D grid world, in which all obstacles and robots are unit squares,
and for each actuation, robots move maximally until they collide with an
obstacle or another robot. In previous work, we demonstrated simulating  arbitrary digital circuits. In this work we describe algorithms for designing obstacles to create arbitrary 2D structures

\end{abstract}

%###############################################################
\section{Introduction}\label{sec:Intro}
%###############################################################

One of the exciting new directions of robotics is the design and development
of micro- and nanorobot systems, with the goal of letting a massive swarm of robots
perform complex operations in a complicated environment. Due to scaling 
issues, individual control of the involved robots becomes physically impossible:
while energy storage capacity drops with the third power of robot size,
medium resistance decreases much slower. As a consequence,
current micro- and nanorobot systems with many robots are steered and
directed by an external force that acts as a common control signal~\cite{Donald2013,Chiang2011,Hsi-Wen2012,Diller2013,Jing2013,Ou2013,Lanauze2013}.
These common control signals include global magnetic or electric fields,
chemical gradients, and turning a light source on and off.  

Clearly, having only one global signal that uniformly affects all robots at once
poses a strong restriction on the ability of the swarm to perform complex operations.
The only hope for breaking symmetry is to use interactions between the robot swarm
and obstacles in the environment. The key challenge is to establish
if interactions with obstacles are sufficient to perform complex operations, ideally by analyzing the complexity of possible logical operations.
 In previous work \cite{Becker2013f,Becker2014,Becker2014a},
we were able to demonstrate how a subset of logical functions can be implemented;
however, devising a fan-out gate (and thus the ability to replicate and copy information)
appeared to be prohibitively challenging. In this paper, we resolve this crucial question by
showing that only using unit-sized robots is insufficient for achieving computational
universality. Remarkably, adding a limited number of domino-shaped objects {\em is sufficient}
to let a common control signal, mobile particles, and unit-sized obstacles
simulate a computer. While this does not imply that large-scale computational 
tasks should be run on these particle computers instead of current electronic
devices, it establishes that future nano-scale systems are able to perform
arbitrarily complex operations {\em as part of the physical system}, instead
of having to go through external computational devices.
% We do not present particle logic as an alternative
%to electronic computing.
%Frankly, this form of computation is impractical. It is slow, requires large
%amounts of space, and is vulnerable to manufacturing defects. Rather, we
%quantify the computing power of mobile robotics at the most simple level in
%order to gain insight for massively-parallel, automated assembly at the micro
%and nano length-scales.

   \begin{figure}
   \centering
   \href{http://youtu.be/EJSv8ny31r8}{
\begin{overpic}[width =\columnwidth]{DSC_0093lowres.JPG}%\put(30,-7){ $m=1$, partition 1}
\end{overpic}}
\caption{\label{fig:prototype}
Gravity-fed hardware implementation of  particle computation.  The reconfigurable prototype is setup as a {\sc fan-out} gate using a 2$\times$1 robot (white). This paper proves that such a gate is impossible using only 1$\times$1 robots. \href{http://youtu.be/EJSv8ny31r8}{See the demonstrations in the video attachment \url{http://youtu.be/EJSv8ny31r8}.} }
\vspace{-1em}
\end{figure}

 \subsection{Model}
  
This paper builds on the techniques for controlling many simple robots with uniform control inputs presented in \cite{Becker2013f,Becker2014,Becker2014a}, using the following rules:
\begin{enumerate}
\item A planar  grid \emph{workspace} $W$ is filled with a number of unit-square robots (each occupying one cell of the grid)  and some fixed unit-square blocks.  Each unit square in the workspace is either  \emph{free}, which a robot may occupy or \emph{obstacle} which a robot may not occupy.  Each square in the grid can be referenced by its Cartesian coordinates $\bm{x}=(x,y)$.
\item All robots are commanded in unison: the valid commands are  ``Go Up" ($u$), ``Go Right" ($r$), ``Go Down" ($d$), or ``Go Left" ($l$).  
\item Robots all move in the commanded direction until they 
	\begin{enumerate}
		\item hit an obstacle 
		\item hit a stationary robot. 
		\item share an edge with a compatible robot
	\end{enumerate}
	If a robot shares an edge with a compatible robot the two robots bond and from then on move as a unit.
A \emph{command sequence} $\bm{m}$ consists of an ordered sequence of moves $m_k$, where each $m_k\in\{u,d,r,l\}$  A representative command sequence is $\langle u,r,d,l,d,r,u,\ldots\rangle$. We assume the area of $W$ is finite and issue each command long enough for the robots to reach their maximum extent.
\end{enumerate}



%###############################################################
\section{Related Work}\label{sec:RelatedWork}
%###############################################################
Our efforts have similarities with \emph{mechanical computers},  computers
constructed from mechanical, not electrical components. For a fascinating
nontechnical review, see \cite{McCourtney1999}.  These devices have a rich
history, from the \emph{Pascaline}, an adding machine invented in 1642 by a
nineteen-year old Blaise Pascal; Herman Hollerith's punch-card tabulator in
1890; to the mechanical devices of IBM culminating in the 1940s.  These devices
used precision gears, pulleys, or electric motors to carry out calculations.
Though our {\sc Grid-World} implementations are rather basic, 
we require none of these precision elements---merely unit-size obstacles,  and
sliding particles sized 2$\times$1 and 1$\times$1 for achieving computational universality.
%Can we call these robots? Indeed, the ENIAC itself was labelled a robot by the
%associated press when it was announced in the 1940s. 

\subsection{Collision-Based Computing}
Collision-based computing has been defined as \emph{``computation in a structureless medium populated with mobile objects''}.  For a survey of this area, see the excellent collection~\cite{Adamatzky2012}. Early examples include the billiard-ball computer proposed by Fredkin and Toffoli using only spherical balls and a frictionless environment composed of elastic collisions with other balls and with angled walls \cite{Fredkin1982ConservativeLogic}. Another popular example is Conway's {\em Game of Life}, a cellular automaton governed by four simple rules~\cite{berlekamp2001winning}. Cells live or die based on the number of neighbors. These rules have been examined in depth and used to design a Turing-complete computer \cite{Adamatzky2002}.  Game of life scenarios and billiard-ball computers are fascinating, but lack a physical implementation.  In this paper we present a collision-based system for computation and provide a physical implementation.
%\textcolor{red}{Todo: this paragraph is incomplete}


\subsection{Sliding-Block Puzzles}
Sliding-block puzzles use rectangular tiles that are constrained to move in a 2D workspace. The objective is to move one or more tiles to desired locations. They have a long history.
Hearn \cite{hearn2005complexity} and Demaine \cite{Demaine2009} showed tiles can be arranged to create logic gates, and used this technique to prove {\sc pspace} complexity for a variety of sliding-block puzzles.  Hearn expressed the idea of building computers from the sliding blocks---many of the logic gates could be connected together, and the user could propagate a signal from one gate to the next by sliding intermediate tiles.  This requires the user to know precisely which sequence of gates to enable/disable.  In contrast to such a hands-on approach, with our architecture we can build circuits, store parameters in memory, and then actuate the entire system in parallel using a global control signal.

\subsection{Other Related Work on Programmable Matter}
Clearly there is a wide range of interesting scenarios for developing approaches to programmable matter.
One such model is the \emph{abstract Tile-Assembly Model} (aTAM) by Winfree~\cite{Winf98,WLWS98,LaWiRe99}, which has 
sparked a wide range of theoretical and practical research. In this model, unit-sized pixels (``tiles'')
interact and bond with the help of differently labeled edges, eventually composing complex assemblies.
Even though the operations and final objectives in this model are quite different from our particle computation with global
inputs (e.g., key features of the aTAM are that tiles can have a wide range of different edge types, and
that they keep sticking together after bonding), there is
a remarkable geometric parallelism to a key result of our present paper:
While it is widely believed that at the most basic level of interaction (called {\em temperature 1}),
computational universality {\em cannot be achieved}~\cite{LSAT1,ManuchTemp1,IUNeedsCoop} in the aTAM with only unit-sized pixels, 
very recent work~\cite{fhp+-ucapt-15} shows that computational universality {\em can be achieved} as soon as even slightly bigger tiles are used. 
This resembles the results of our paper, which shows that unit-size particles are insufficient for universal computation, while employing bigger particles suffices


%###############################################################
\section{Construction}\label{sec:Construction}
%###############################################################


%###############################################################
\subsection{How many species are required to build an arbitrary 2D shape?}\label{subsec:RobotSpecies}
%###############################################################
A \emph{polyomino} is a 2D geometric figure formed by joining one or more equal squares edge to edge. Polyominoes have four-point connectivity.


\begin{lemma}
  Any polyomino can be constructed using just two species
  \end{lemma}
\begin{proof} 
Label a grid with an alternating pattern like a checkerboard.  Any desired polyomino can be constructed on this checkerboard, and all joints are between dissimilar species.
  An example shape is shown in Fig.~\ref{fig:Grid}.
  \end{proof}
  
  The sufficiency of two species to construct any shape gives many options for implementation.  The two species could correspond to any gendered connection, 
including electric charge, ionic charge, magnetic polarity, or hook-and-loop type fasteners.


   \begin{figure}
   \centering
\begin{overpic}[width =.3\columnwidth]{Grid.pdf}
\end{overpic}
\caption{\label{fig:Grid}Any polyomino can be constructed with two compatible robot species.  
}
\end{figure}


%###############################################################
\subsection{Hopper Construction}\label{subsec:HopperConstruction}
%###############################################################
Two-part adhesives react when the components mix.  Placing the components in separate containers prevents mixing.  Similarly, storing many particles of a single species in separate containers allows controlled mixing.
%WIKI: harden by mixing two or more components which chemically react.

We can design \emph{part hoppers}, containers that store similarly labelled particles.  These particles will not bond with each other.  The hopper shown in Fig.~\ref{fig:HopperCW} releases one particle every cycle.
   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{HopperCW.pdf}
\end{overpic}
\caption{\label{fig:HopperCW}This hopper is filled with similarly-labelled robots that will not combine.  Every clockwise command sequence $\langle u,r,d,l \rangle$ releases one robot from the hopper. 
}
\end{figure}


\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{7tilefactory.jpg}
\end{overpic}
\caption{\label{fig:7tilefactory}A seven tile factory
}
\end{figure}


\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{24tilefactory.jpg}
\end{overpic}
\caption{\label{fig:24tilefactory}A twenty four tile factory
}
\end{figure}


\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{HopperDelays.jpg}
\end{overpic}
\caption{\label{fig:24tilefactory}Hopper with delays
}
\end{figure}



\begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{DownMove.jpg}
\end{overpic}
\caption{\label{fig:24tilefactory}Tile being attached to a three tile part by down move
}
\end{figure}





%###############################################################
\subsection{Part Assembly Jigs}\label{subsec:PartAssemblyJigs}
%###############################################################

%###############################################################
\section{Design Rules}\label{sec:DesignRules}
%###############################################################


\todo{Sheryl, add the algorithmic environment for Build Factory}
\newcommand\algotext[1]{\end{algorithmic}#1\begin{algorithmic}[1]}
\begin{algorithm} 
\caption{The BuildFactory algorithm}
\begin{algorithmic}[1]
 \Function{BuildFactory}{$partXY$, $numCopies$}
 \Function{FindBuildPath}{$partXY$}
 \If{$false=IsPossible$}
 return
 \EndIf
 \EndFunction
 \For{$i\leftarrow 2,size(sequenceXY)$}
\Function{factoryAddTile}\newline{$partXYbuild$,$XYcoord$,$directions$,$partColoredArray$}
return factoryObstacleAdditionArray, partXYbuild
\EndFunction
\Function{concatfactories}\newline{$factoryLayoutArray$,$factoryObstacleadditionArray$}
return factoryLayoutArray
\EndFunction
\EndFor
\Function{DisplayFactory}\newline{$factoryLayoutArray$}
\EndFunction
\EndFunction
\end{algorithmic}
\end{algorithm} 
 
 
 
\begin{algorithm} 
\caption{The factoryAddTile algorithm}
\begin{algorithmic}[2]
\Function{factoryAddTile}{$partXY$, $tileXY$, $dir$, $tileColor$, $numCopies$, $pos$}
\Function{Hopper}{$tileColor$,$numCopies$,$4$,$pos$}
\newline return hopper, hopper_size
\EndFunction
\If{$dir='d'$}
$maxpartx=max(partXY(:,2));$
\If{$tileXY(1,2)<=maxpartx$}
\Function{downdir}{$hopper$,$partXY$,$tileXY$}
return factoryObstacleAdditionArray, align
\EndFunction
\Else
\Function{leftdir}\newline{$hopper$,$partXY$,$tileXY$}
\newline return factoryObstacleAdditionArray, align
\EndFunction
\EndIf
\EndIf

\If{$dir='l'$}
$maxparty=max(partXY(:,1));$
\If{$tileXY(1,1)<=maxparty$}
\Function{leftdir}\newline{$hopper$,$partXY$,$tileXY$}
\newline return factoryObstacleAdditionArray, align
\EndFunction
\Else
\Function{updir}{$hopper$,$partXY$,$tileXY$}
return factoryObstacleAdditionArray, align
\EndFunction
\EndIf
\EndIf


\If{$dir='u'$}
$minpartx=min(partXY(:,2));$
\If{$tileXY(1,2)>=minpartx$}
\Function{updir}{$hopper$,$partXY$,$tileXY$}
return factoryObstacleAdditionArray, align
\EndFunction
\Else
\Function{rightdir}{\newline $hopper$,$partXY$,$tileXY$}
\newline return factoryObstacleAdditionArray, align
\EndFunction
\EndIf
\EndIf


\If{$dir='r'$}
$minparty=min(partXY(:,1));$
\If{$tileXY(1,1)>=minparty$}
\Function{rightdir}{\newline $hopper$,$partXY$,$tileXY$}
\newline return factoryObstacleAdditionArray, align
\EndFunction
\Else
\Function{downdir}{$hopper$,$partXY$,$tileXY$}
return factoryObstacleAdditionArray, align
\EndFunction
\EndIf
\EndIf
\newline return partXYupdated, factoryObstacleAdditionArray, align, hopper_size
\EndFunction
\end{algorithmic}[2]
\end{algorithm}
 
 
 
 
 
 
\begin{algorithm} 
\caption{The FindBuildPath algorithm}
\begin{algorithmic}[3]
\Function{FindBuildPath}{$partXY$}
\For{$m=1:partXY(:,1)$}
\newline $Start = partXY(m,:);$
\Function{DepthFirstSearch}{$partXY$,$Start$}
return Output, Seq, Tmppart
\EndFunction
\newline $partColored = labelColor(Tmppart(:,:,1));$
$partialAssembly = zeros(size(Tmppart(:,:,1),1),size(Tmppart(:,:,1),2));$
$partialAssembly(Output(1,1),Output(1,2)) = 1;$
$dirsFinal= size(partXY,1)-1;$
\newline $dirsFinal = char(dirsFinal);$
\newline $dirs2 = ['d';'l';'u';'r'];$
\For{$i=2:size(Output,1)$}
\For{$j=1:4$}
\Function{CheckPath1Tile}{\newline$partialAssembly$,$Output(i,:)$,$dirs2(j,:)$,$partColored$}
\newline return move
\EndFunction
\If{$strcmp(move,'true')$}
$partialAssembly(Output(i,1),Output(i,2)) = 1;$
$dirsFinal(i-1,:) = num2str(dirs2(j,:));$
\newline $break;$
\EndIf
\EndFor
\If{$strcmp(move,'false') \& m~=size(partXY,1)$}
$clear output seq tmp_part partColored partialAssembly dirs_final;$
$break;$
\EndIf
\If{$strcmp(move,'true') \& i==size(Output,1)$}
$foundPath=true; $
\EndIf
\EndFor
\If{$foundPath==true$}
$sequence = Output;$
$dirs = dirsFinal;$
$partColoredArray = partColored;$
$break;$ 
\EndIf
\EndFor
\newline return foundPath, sequence, dirs, partColoredArray
\EndFunction
\end{algorithmic}[3]
\end{algorithm} 
  
 
 
 
 



Different 2D part geometries are more difficult to construct than others.  Fig.~\ref{fig:IncreasingDifficulty} shows three parts of varying complexity.  The part of the left is shaped as a `\#' symbol.  Though it has an interior hole, any of the 16 particles could serve as the seed particle, and the shape could be constructed around it.  The second shape is a spiral, and must be constructed from the inside-out.  If the outer spiral was completed first, there would be no path to add particles to finish the interior because added particles would have to slide past compatible particles.  Increasing the number of species would not solve this problem, because there is a narrow passage through the spiral that forces incoming parts to slide past the edges of all the bonded particles.

The third shape on the right is two mirrored spirals that are connected.  This part cannot be assembled by adding one particle at a time, because each spiral must be constructed from the inside-out.  Instead, this part must be divided into sub-assemblies that are each constructed, and then combined.

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{IncreasingDifficulty2.pdf}
\end{overpic}
\caption{\label{fig:IncreasingDifficulty}Polyomino parts. Difficulty increases from left to right. The rightmost part cannot be built by additive construction. 
}
\end{figure} 






 A polyomino is said to be \emph{column convex} if each column has no holes. Similarly, a polyomino is said to be row convex if each row has no holes. A polyomino is said to be \emph{convex} if it is row and column convex.

\begin{lemma}\label{lemma:convexonjectsCanbeConstructedAdditively}
Any convex polyomino can be constructed by adding one particle at a time
\end{lemma}
\begin{proof}
Select any pixel as the \emph{seed block}, or root node.  Perform a breadth-first search starting at the seed block, labelling each block in the order they are expanded.  Constructing the shape according to the ordering ensures that the polyomino is convex at every step of construction.
\end{proof}

The proof of \ref{lemma:convexonjectsCanbeConstructedAdditively} assumes the existence of fixtures for assembly.
\todo{describe fixtures for adding one particle at a time}





%###############################################################
\subsection{Sub Assemblies for Additive Manufacture}\label{subsec:SubAssemblies}
%###############################################################
Some non-convex polynominos cannot be constructed one particle at a time, as illustrated in Fig. ~\ref{fig:IncreasingDifficulty}.    For instance, a polynomino consisting of a clockwise and a counterclockwise square spiral, joined at the ends with a gap of one unit between the spirals must be constructed by first assembling each spiral, and then combining the sub assemblies.



\begin{lemma}\label{lemma:nonconvexObjectsCanBeDecomposedIntoConvex}
Any non-convex polyomino can be disassembled into convex sub-assemblies.
\end{lemma}
\begin{proof}
How do you decompose an arbitrary polyomino into convex sub assemblies?
\end{proof}

The proof of \ref{lemma:nonconvexObjectsCanBeDecomposedIntoConvex} requires 




%###############################################################
\subsection{Combining Sub Assemblies}\label{subsec:CombineSubAssemblies}
%###############################################################

\todo{provide design rules for fixtures that combine arbitrary sized  sub-assemblies}

   \begin{figure}
   \centering
\begin{overpic}[width =\columnwidth]{TetrisOne.jpg}
\end{overpic}
\caption{\label{fig:TetrisOne}A factory hand-designed for constructing a $\bot$  tetromino using four hoppers and a clockwise global input.
}
\end{figure} 

%###############################################################
\section{Experiment}\label{sec:Experiment}
%###############################################################



%###############################################################
\section{Conclusion}\label{sec:Conclusion}
%###############################################################
In this paper we 

This work, along with \cite{Becker2013f,Becker2014,Becker2014a}, introduces a
new model for additive assembly.  Interesting applications will aim at 
nanoscale and microfluidics work.

    
%\section{Acknowledgements}
%This work was supported by the National Science Foundation under
%\href{http://nsf.gov/awardsearch/showAward?AWD_ID=1208509}{NRI-1208509}.  
   
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../../RoboticSwarmControlLab/bib/aaronrefs}%,../aaronrefs} %../../../../../../ensemble/bib/aaronrefs}


\end{document}


