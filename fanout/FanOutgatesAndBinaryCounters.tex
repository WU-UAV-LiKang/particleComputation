% easy truth tables: http://www.kwi.dk/projects/php/truthtable/?
%  177199 Hamed Mohtasham shad
% 177228 Rose Morris-Wright
%
% TODO: assembly (we can implement aTAM!) , 
% could we add tiny magnets to robot sides to make them link up?
% can we place our prototype  on an inclined lazy susan?
\pdfobjcompresslevel=0  % I had adobe error 131, and this removed it: http://tex.stackexchange.com/questions/64448/how-to-overcome-acrobat-reader-error-131-with-a-pdflatex-doc

\documentclass[letterpaper, 10 pt, conference]{ieeeconf}
\IEEEoverridecommandlockouts
\usepackage{calc}
\usepackage{url}
\usepackage{hyperref}
\hypersetup{
  colorlinks =true,
  urlcolor = black,
  linkcolor = black
}
\usepackage{graphicx}
\usepackage[cmex10]{amsmath}
\usepackage{amssymb}
\usepackage{rotating}
\usepackage{booktabs}

\usepackage{nicefrac}
\usepackage{cite}
\usepackage[caption=false,font=footnotesize]{subfig}
\usepackage[usenames, dvipsnames]{color}
\usepackage{colortbl}
\usepackage{overpic}
\graphicspath{{./pictures/pdf/},{./pictures/ps/},{./pictures/png/},{./pictures/jpg/}}
\usepackage{breqn} %for breaking equations automatically
\usepackage[ruled]{algorithm}
\usepackage{algpseudocode}
\usepackage{multirow}

\usepackage{bm}   % boldface math type
\usepackage{soul}  % for highlighting
\newcommand{\todo}[1]{\vspace{5 mm}\par \noindent \framebox{\begin{minipage}[c]{0.98 \columnwidth} \ttfamily\flushleft \textcolor{red}{#1}\end{minipage}}\vspace{5 mm}\par}
% uncomment this to hide all red todos
%\renewcommand{\todo}{}

%% ABBREVIATIONS
\newcommand{\qstart}{q_{\text{start}}}
\newcommand{\qgoal}{q_{\text{goal}}}
\newcommand{\pstart}{p_{\text{start}}}
\newcommand{\pgoal}{p_{\text{goal}}}
\newcommand{\xstart}{x_{\text{start}}}
\newcommand{\xgoal}{x_{\text{goal}}}
\newcommand{\ystart}{y_{\text{start}}}
\newcommand{\ygoal}{y_{\text{goal}}}
\newcommand{\gammastart}{\gamma_{\text{start}}}
\newcommand{\gammagoal}{\gamma_{\text{goal}}}
\providecommand{\proc}[1]{\textsc{#1}}


\newcommand{\ARLfull}{Aero\-space Ro\-bot\-ics La\-bora\-tory }
\newcommand{\ARL}{\textsc{arl}}
\newcommand{\JPL}{\textsc{jpl}}
\newcommand{\PRM}{\textsc{prm}}
\newcommand{\CM}{\textsc{cm}}
\newcommand{\SVM}{\textsc{svm}}
\newcommand{\NN}{\textsc{nn}}
\newcommand{\prm}{\textsc{prm}}
\newcommand{\lemur}{\textsc{lemur}}
\newcommand{\Lemur}{\textsc{Lemur}}
\newcommand{\LP}{\textsc{lp}} 
\newcommand{\SOCP}{\textsc{socp}}
\newcommand{\SDP}{\textsc{sdp}}
\newcommand{\NP}{\textsc{np}}
\newcommand{\SAT}{\textsc{sat}}
\newcommand{\LMI}{\textsc{lmi}}
\newcommand{\hrp}{\textsc{hrp\nobreakdash-2}}
\newcommand{\DOF}{\textsc{dof}}
\newcommand{\UIUC}{\textsc{uiuc}}
%% MACROS


\providecommand{\abs}[1]{\left\lvert#1\right\rvert}
\providecommand{\norm}[1]{\left\lVert#1\right\rVert}
\providecommand{\normn}[2]{\left\lVert#1\right\rVert_#2}
\providecommand{\dualnorm}[1]{\norm{#1}_\ast}
\providecommand{\dualnormn}[2]{\norm{#1}_{#2\ast}}
\providecommand{\set}[1]{\lbrace\,#1\,\rbrace}
\providecommand{\cset}[2]{\lbrace\,{#1}\nobreak\mid\nobreak{#2}\,\rbrace}
\providecommand{\lscal}{<}
\providecommand{\gscal}{>}
\providecommand{\lvect}{\prec}
\providecommand{\gvect}{\succ}
\providecommand{\leqscal}{\leq}
\providecommand{\geqscal}{\geq}
\providecommand{\leqvect}{\preceq}
\providecommand{\geqvect}{\succeq}
\providecommand{\onevect}{\mathbf{1}}
\providecommand{\zerovect}{\mathbf{0}}
\providecommand{\field}[1]{\mathbb{#1}}
\providecommand{\C}{\field{C}}
\providecommand{\R}{\field{R}}
\newcommand{\Cspace}{\mathcal{Q}}
\newcommand{\Uspace}{\mathcal{U}}
\providecommand{\Fspace}{\Cspace_\text{free}}
\providecommand{\Hcal}{$\mathcal{H}$}
\providecommand{\Vcal}{$\mathcal{V}$}
\DeclareMathOperator{\conv}{conv}
\DeclareMathOperator{\cone}{cone}
\DeclareMathOperator{\homog}{homog}
\DeclareMathOperator{\domain}{dom}
\DeclareMathOperator{\range}{range}
\DeclareMathOperator{\sign}{sgn}
\DeclareMathOperator{\sgn}{signum}
\providecommand{\polar}{\triangle}
\providecommand{\ainner}{\underline{a}}
\providecommand{\aouter}{\overline{a}}
\providecommand{\binner}{\underline{b}}
\providecommand{\bouter}{\overline{b}}
\newcommand{\D}{\nobreakdash-\textsc{d}}
%\newcommand{\Fspace}{\mathcal{F}}
\providecommand{\Fspace}{\Cspace_\text{free}}
\providecommand{\free}{\text{\{}\mathsf{free}\text{\}}}
\providecommand{\iff}{\Leftrightarrow}
\providecommand{\subinner}[1]{#1_{\text{inner}}}
\providecommand{\subouter}[1]{#1_{\text{outer}}}
\providecommand{\Ppoly}{\mathcal{X}}
\providecommand{\Pproj}{\mathcal{Y}}
\providecommand{\Pinner}{\subinner{\Pproj}}
\providecommand{\Pouter}{\subouter{\Pproj}}
\DeclareMathOperator{\argmax}{arg\,max}
\providecommand{\Aineq}{B}
\providecommand{\Aeq}{A}
\providecommand{\bineq}{u}
\providecommand{\beq}{t}
\DeclareMathOperator{\area}{area}
\newcommand{\contact}[1]{\Cspace_{#1}}
\newcommand{\feasible}[1]{\Fspace_{#1}}
\newcommand{\dd}{\; \mathrm{d}}
\newcommand{\figwid}{0.22\columnwidth}

\DeclareMathOperator{\atan2}{atan2}


\newtheorem{theorem}{Theorem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\begin{document}

%%%%%%%%%%%%%% For debugging purposes, I like to display the TOC
%\tableofcontents
%\setcounter{tocdepth}{3}
%\newpage
%\mbox{}
%\newpage
%\mbox{}
%\newpage
%%%%%% END TOC %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\LARGE \bf 
Particle Computation:  Device Fan-out and Binary Memory 
}
\author{
Hamed Mohtasham Shad,
Rose Morris-Wright,
Erik D. Demaine,
S\'andor P. Fekete,
Aaron T. Becker
\thanks{{
H. Mohtasham  \protect\url{mohtasham@gmail.com},
R.~Morris-Wright  \protect\url{rmorriswright@gmail.com},
E.~Demaine is with the Computer Science and Artificial Intelligence Laboratory, MIT, Cambridge, MA 02139, USA,      \protect\url{edemaine@mit.edu},
S.~Fekete is with the Dept.~of Computer Science, TU Braunschweig,  M\"uhlenpfordtstr.~23, 38106 Braunschweig, Germany,
      \protect\url{s.fekete@tu-bs.de},
A.~Becker is with the  Dept.~of Electrical and Computer Engineering,  University of Houston, Houston, TX 70004, USA {\tt\small atbecker@uh.edu}.
}
} %\end thanks
} % end author block
\maketitle



\begin{abstract} 
We present fundamental progress on the computational universality of swarms of micro- or nano-scale robots
in complex environments, controlled not by individual navigation, but by a uniform global, external force.
Consider a 2D grid world, in which all obstacles and robots are unit squares,
and for each actuation, robots move maximally until they collide with an
obstacle or another robot. In previous work, we demonstrated components of \emph{particle computation} in this
world, designing obstacle configurations that implement {\sc and} and {\sc or}
logic gates:  by using dual-rail logic, we designed {\sc not, nor, nand, xor,
xnor} logic gates. However, we were unable to design a {\sc fan-out} gate, which
is necessary for simulating the full range of complex interactions
that are present in arbitrary digital circuits. In this work we resolve this 
problem by proving unit-sized robots {\em cannot} generate a {\sc fan-out} gate.  
On the positive side, we resolve the missing component with the help of 
2$\times$1 robots, which can create fan-out gates that produce multiple copies
of the inputs.  Using these gates we are able to establish the full range
of computational universality as presented by complex digital circuits.  As
an example we connect our logic elements to produce a 3-bit counter.  We also
demonstrate how to implement a data storage element.

%We present fundamental progress on the computational universality of swarms of micro- or nano-scale robots in complex environments, controlled not by individual navigation, but by a uniform global, external force. Consider a 2D grid world, in which all obstacles and robots are unit squares, and for each actuation, robots move maximally until they collide with an obstacle or another robot. In previous work, we demonstrated components of particle computation in this world, designing obstacle configurations that implement AND and OR logic gates:  by using dual-rail logic, we designed NOT, NOR, NAND, XOR, XNOR logic gates. However, we were unable to design a FAN-OUT gate, which is necessary for simulating the full range of complex interactions that are present in arbitrary digital circuits. In this work we resolve this problem by proving unit-sized robots cannot generate a FAN-OUT gate. On the positive side, we resolve the missing component with the help of  2x1 robots, which can create fan-out gates that produce multiple copies of the inputs.  Using these gates we are able to establish the full range of computational universality as presented by complex digital circuits.  As an example we connect our logic elements to produce a 3-bit counter.  We also demonstrate how to implement a data storage element.
\end{abstract}


%\textcolor{red}{In general pay more attention to structuring each paragraph so that you guide your reader by telling them first what you will accomplish in that paragraph and then making sure you support all your assertions.}

%###############################################################
\section{Introduction}
%###############################################################

One of the exciting new directions of robotics is the design and development
of micro- and nanorobot systems, with the goal of letting a massive swarm of robots
perform complex operations in a complicated environment. Due to scaling 
issues, individual control of the involved robots becomes physically impossible:
while energy storage capacity drops with the third power of robot size,
medium resistance decreases much slower. As a consequence,
current micro- and nanorobot systems with many robots are steered and
directed by an external force that acts as a common control signal~\cite{Donald2013,Chiang2011,Hsi-Wen2012,Diller2013,Jing2013,Ou2013,Lanauze2013}.
These common control signals include global magnetic or electric fields,
chemical gradients, and turning a light source on and off.  

Clearly, having only one global signal that uniformly affects all robots at once
poses a strong restriction on the ability of the swarm to perform complex operations.
The only hope for breaking symmetry is to use interactions between the robot swarm
and obstacles in the environment. The key challenge is to establish
if interactions with obstacles are sufficient to perform complex operations, ideally by analyzing the complexity of possible logical operations.
 In previous work \cite{Becker2013f,Becker2014,Becker2014a},
we were able to demonstrate how a subset of logical functions can be implemented;
however, devising a fan-out gate (and thus the ability to replicate and copy information)
appeared to be prohibitively challenging. In this paper, we resolve this crucial question by
showing that only using unit-sized robots is insufficient for achieving computational
universality. Remarkably, adding a limited number of domino-shaped objects {\em is sufficient}
to let a common control signal, mobile particles, and unit-sized obstacles
simulate a computer. While this does not imply that large-scale computational 
tasks should be run on these particle computers instead of current electronic
devices, it establishes that future nano-scale systems are able to perform
arbitrarily complex operations {\em as part of the physical system}, instead
of having to go through external computational devices.
% We do not present particle logic as an alternative
%to electronic computing.
%Frankly, this form of computation is impractical. It is slow, requires large
%amounts of space, and is vulnerable to manufacturing defects. Rather, we
%quantify the computing power of mobile robotics at the most simple level in
%order to gain insight for massively-parallel, automated assembly at the micro
%and nano length-scales.

   \begin{figure}
   \centering
   \href{http://youtu.be/EJSv8ny31r8}{
\begin{overpic}[width =\columnwidth]{DSC_0093lowres.JPG}%\put(30,-7){ $m=1$, partition 1}
\end{overpic}}
\caption{
\label{fig:prototype}
Gravity-fed hardware implementation of  particle computation.  The reconfigurable prototype is setup as a {\sc fan-out} gate using a 2$\times$1 robot (white). This paper proves that such a gate is impossible using only 1$\times$1 robots. \href{http://youtu.be/EJSv8ny31r8}{See the demonstrations in the video attachment \url{http://youtu.be/EJSv8ny31r8}.} }
\vspace{-1em}
\end{figure}

 \subsection{Model}
  
This paper builds on the techniques for controlling many simple robots with uniform control inputs presented in \cite{Becker2013f,Becker2014,Becker2014a}, using the following rules:
\begin{enumerate}
\item A planar  grid \emph{workspace} $W$ is filled with a number of unit-square robots (each occupying one cell of the grid)  and some fixed unit-square blocks.  Each unit square in the workspace is either  \emph{free}, which a robot may occupy or \emph{obstacle} which a robot may not occupy.  Each square in the grid can be referenced by its Cartesian coordinates $\bm{x}=(x,y)$.
\item All robots are commanded in unison: the valid commands are  ``Go Up" ($u$), ``Go Right" ($r$), ``Go Down" ($d$), or ``Go Left" ($l$).  
\item The robots all move in the commanded direction until they hit an obstacle or a stationary robot. A \emph{command sequence} $\bm{m}$ consists of an ordered sequence of moves $m_k$, where each $m_k\in\{u,d,r,l\}$  A representative command sequence is $\langle u,r,d,l,d,r,u,\ldots\rangle$. We assume the area of $W$ is finite and issue each command long enough for the robots to reach their maximum extent.
\end{enumerate}


 \subsection{Dual-Rail Logic and {\sc fan-out} Gates}

As shown in \cite{Becker2013f}, {\sc and} and {\sc or} can be implemented with
unit-size particles.  However, particle logic is \emph{conservative}---particles
are neither created nor destroyed---and we were unable to implement a {\sc not}
gate. To implement {\sc not} gates and other logic we used \emph{dual-rail
logic}, where two lines for each input are supplied to explicitly represent the
variable and its complement~\cite{Becker2014a}. Here we show that dual-rail
logic is necessary, as single-rail logic is insufficient to produce a {\sc not}
gate. 

  The \emph{fan out} of a logic gate output is the number of gate inputs it can feed or connect to.  With particle logic, as demonstrated in  \cite{Becker2014}, each logic gate output could fan out to only one gate.  This is sufficient for \emph{sum of products} and \emph{product of sums}  operations in CPLDs (complex programmable logic devices), but insufficient for more flexible architectures.
  %  In digital electronics, the fan-out of a logic gate output is the number of gate inputs it can feed or connect to.
%In most designs, logic gates are connected to form more complex circuits. While no more than one logic gate output is connected to any single input, it is common for one output to be connected to several inputs. The technology used to implement logic gates usually allows a certain number of gate inputs to be wired directly together without additional interfacing circuitry. The maximum fan-out of an output measures its load-driving capability: it is the greatest number of inputs of gates of the same type to which the output can be safely connected. http://en.wikipedia.org/wiki/fan-out
%  
    Consider the half-adder shown in Fig.~\ref{fig:HalfAdder}.  The inputs $\mathbf{A}$ and  $\mathbf{B}$ are needed to compute both the {\sc sum} and the {\sc carry} bits, so the fanout of $\mathbf{A}$ and  $\mathbf{B}$ is two. In this paper we prove the insufficiency of unit-sized particles for the implementation of fan-out gates, and design a fan-out gate using $2\times 1$ particles. 
  
  



%%%%%Unfounded Assertion... would be a cool proof later. Can we reverse particle logic? 
%Unfortunately particle logic is not reversible.   The {\sc or} gate outputs a 1 if either input is asserted, but afterwards we cannot determine which input was high.  This makes implementing a {\sc fan-out} gate impossible with unit-size particles and obstacles.
%\textcolor{red}{This paragraph is confusing to me. You're making a lot of assertions and there are a lot of different ideas that aren't fully explained or backed up. Either split it into several paragraphs where you can explain each idea in more detail or save these ideas for later in the paper when you can support them more fully. This is a good place to define dual-real logic and conservative but perhaps we can find a way to do it and leave these assertions for later on.}

   \begin{figure}
   \centering
\begin{overpic}[width =0.49\columnwidth]{HalfAdder}%\put(30,-7){ $m=1$, partition 1}
\end{overpic}
\caption{
\label{fig:HalfAdder}
The half adder shown above requires two copies of  $\mathbf{A}$ and  $\mathbf{B}$.
}
\vspace{-1em}
\end{figure}

\subsection{Contributions}
  
 After a brief overview of related work,  the contributions of this paper are as follows:
  \begin{enumerate}
  \item We prove the necessity of dual-rail logic for Boolean logic (Section \ref{sec:theory}).
  \item We prove the insufficiency of unit-size particles for gate fan-out (Section \ref{sec:theory}).
  \item We design {\sc fan-out} gates (Section \ref{sec:FanOut}).
  \item We design memory latches (Section \ref{subsec:Storage}).
  \item We present architecture for device integration, design a common clock sequence, and present a binary counter (Section \ref{sec:binaryCounter}).
    \item We present the design and implementation of a large-scale particle computation prototype (Section \ref{sec:Experiment}).
    \end{enumerate}

%###############################################################
\section{Related Work}\label{sec:RelatedWork}
%###############################################################
Our efforts have similarities with \emph{mechanical computers},  computers
constructed from mechanical, not electrical components. For a fascinating
nontechnical review, see \cite{McCourtney1999}.  These devices have a rich
history, from the \emph{Pascaline}, an adding machine invented in 1642 by a
nineteen-year old Blaise Pascal; Herman Hollerith's punch-card tabulator in
1890; to the mechanical devices of IBM culminating in the 1940s.  These devices
used precision gears, pulleys, or electric motors to carry out calculations.
Though our {\sc Grid-World} implementations are rather basic, 
we require none of these precision elements---merely unit-size obstacles,  and
sliding particles sized 2$\times$1 and 1$\times$1 for achieving computational universality.
%Can we call these robots? Indeed, the ENIAC itself was labelled a robot by the
%associated press when it was announced in the 1940s. 

\subsection{Collision-Based Computing}
Collision-based computing has been defined as \emph{``computation in a structureless medium populated with mobile objects''}.  For a survey of this area, see the excellent collection~\cite{Adamatzky2012}. Early examples include the billiard-ball computer proposed by Fredkin and Toffoli using only spherical balls and a frictionless environment composed of elastic collisions with other balls and with angled walls \cite{Fredkin1982ConservativeLogic}. Another popular example is Conway's {\em Game of Life}, a cellular automaton governed by four simple rules~\cite{berlekamp2001winning}. Cells live or die based on the number of neighbors. These rules have been examined in depth and used to design a Turing-complete computer \cite{Adamatzky2002}.  Game of life scenarios and billiard-ball computers are fascinating, but lack a physical implementation.  In this paper we present a collision-based system for computation and provide a physical implementation.
%\textcolor{red}{Todo: this paragraph is incomplete}


\subsection{Sliding-Block Puzzles}
Sliding-block puzzles use rectangular tiles that are constrained to move in a 2D workspace. The objective is to move one or more tiles to desired locations. They have a long history.
Hearn \cite{hearn2005complexity} and Demaine \cite{Demaine2009} showed tiles can be arranged to create logic gates, and used this technique to prove {\sc pspace} complexity for a variety of sliding-block puzzles.  Hearn expressed the idea of building computers from the sliding blocks---many of the logic gates could be connected together, and the user could propagate a signal from one gate to the next by sliding intermediate tiles.  This requires the user to know precisely which sequence of gates to enable/disable.  In contrast to such a hands-on approach, with our architecture we can build circuits, store parameters in memory, and then actuate the entire system in parallel using a global control signal.

\subsection{Other Related Work on Programmable Matter}
Clearly there is a wide range of interesting scenarios for developing approaches to programmable matter.
One such model is the \emph{abstract Tile-Assembly Model} (aTAM) by Winfree~\cite{Winf98,WLWS98,LaWiRe99}, which has 
sparked a wide range of theoretical and practical research. In this model, unit-sized pixels (``tiles'')
interact and bond with the help of differently labeled edges, eventually composing complex assemblies.
Even though the operations and final objectives in this model are quite different from our particle computation with global
inputs (e.g., key features of the aTAM are that tiles can have a wide range of different edge types, and
that they keep sticking together after bonding), there is
a remarkable geometric parallelism to a key result of our present paper:
While it is widely believed that at the most basic level of interaction (called {\em temperature 1}),
computational universality {\em cannot be achieved}~\cite{LSAT1,ManuchTemp1,IUNeedsCoop} in the aTAM with only unit-sized pixels, 
very recent work~\cite{fhp+-ucapt-15} shows that computational universality {\em can be achieved} as soon as even slightly bigger tiles are used. 
This resembles the results of our paper, which shows that unit-size particles are insufficient for universal computation, while employing bigger particles suffices.

%###############################################################
\section{Theory}\label{sec:theory}
%###############################################################
%I want catchy names for these theorems
% Sandor suggests:  "Dual-rail logic is necessary" and "only 1*1 tiles are insufficient"

First we provide terminology to define how robots interact with each other. 

%  AARON: I think this line just restated what was said inSection 1-A
%When each $M(k)$, in a particular command sequence $\bm{m}$, is executed all robots move in the specified direction until they are stopped by an obstacle or another robot. Suppose for move $M(k)$, the robot $a$ ends at location $(x,y)$. With the addition of more robots,  it is possible for one robot to hit another.

\paragraph{Definition of hit}
During move $m_k$, robot $a$ \emph{hits} robot $b$ if $a$ is prevented from reaching location $\bm{x}=(x,y)$ because robot $b$ occupies this location. Robot $b$'s location at the end of $m_k$ will be $\bm{x}$ and robot $a$'s location at the end of $m_k$ can be calculated as follows:
\begin{displaymath}
    \left\{
     \begin{array}{ll}
       (x-1,y) &\text{if }m_k=r\\
       (x+1,y) &\text{if }m_k=l\\
       (x,y-1) &\text{if }m_k=u\\
       (x,y+1) &\text{if }m_k=d\\
     \end{array}
   \right.
\end{displaymath} 

\paragraph{Definition of path}
As robot $r$ travels from $\bm{s}$ to $\bm{g}$, it passes through a sequence of locations $\{\bm{s},\ldots,\bm{g}\}$.  We call this sequence of locations $r$'s \emph{path}. 

\begin{lemma}\label{lemma:changeInHitsNeededToChangePath}
Given a workspace $W$, a command sequence $\bm{m}$, and a robot $r$ traveling along a path beginning at location $\bm{s}$, this path can only be changed by introducing a new robot that $r$ hits, or by removing one of the robots that $r$ hit before.
%Given a workspace $W$, a command sequence $\bm{m}$, and a robot $r$ traveling along a path beginning at location $\bm{s}$, this path can only be changed if $r$ hits a robot it did not hit before, or if $r$ fails to hit robots it did hit before.
\end{lemma}

\begin{proof}
By definition, the path is the sequence of locations occupied by the robot. The path is entirely determined by four factors: the starting location of the robot, the command sequence, obstacles in the workspace,  and encounters with other robots already occupying free locations. If no hits with other robots are added or subtracted, then robot $r$ will start in the same place, receive the same command sequence and encounter the same obstacles, so robot $r$'s path will remain unchanged.  Note that $r$'s path is still unchanged if it is hit by another robot. According to our definition of a hit, if robot $q$ hits $r$, then $r$'s path is unchanged, while if robot $r$ hits $q$ then $r$'s path is changed. 
\end{proof}

Now we show that adding more unit-sized robots cannot prevent a location from being occupied at the end of the command sequence.

\begin{theorem}\label{thm:AdditionalRobotsCannotPreventAnOccupation}
If given a workspace $W$ and a command sequence $\bm{m}$ that moves a robot from a start location $\bm{s}$ to a goal location $\bm{g}$, adding additional robots anywhere in $W$ at any stage of the command sequence cannot prevent $\bm{g}$ from being occupied at the conclusion of sequence $\bm{m}$.
\end{theorem}

%This theorem addresses how adding more robots can effect the final outcome. 
\begin{proof} Consider the effect of adding robot $b$ to workspace $W$. If $a$ never hits $b$, then by Lemma \ref{lemma:changeInHitsNeededToChangePath}, $a$'s path remains the same. Therefore, at the conclusion of $\bm{m}$, $a$ occupies $\bm{g}$. 

Now suppose $a$ hits $b$. By the definition of a hit, $b$ prevents $a$ from reaching some location $\bm{x}$ because $b$ already occupies this location. After the hit, the command sequence will continue and so robot $b$ will continue on $a$'s original path, following the same instructions and therefore ending up in the same location, $\bm{g}$ unless $b$ hits yet another robot. By induction, we can clearly see that such additional robots will have the same effect. If $b$ hits any other robot, this robot will continue on the original path. Thus by adding more robots, it is impossible to prevent some robot from occupying $\bm{g}$ at the conclusion of $\bm{m}$.  
%\textcolor{blue}{Should we say something about multiple hits (an inductive proof)? }
\end{proof}

\begin{corollary}
A  {\sc not} gate without dual-rail inputs cannot be constructed.
\end{corollary}
\begin{proof}
By contradiction.
A particle logic {\sc not} gate without dual-rail inputs has one input at $\bm{s}$, one output at $\bm{g}$, an arbitrary, possibly zero, number of asserted inputs which are all initially occupied, and an arbitrary, possibly zero, number of waste outputs.

In order for the {\sc not} gate conditions to be satisfied, given a command sequence $\bm{m}$:  
\begin{enumerate}
\item if $\bm{s}$ is initially unoccupied, $\bm{g}$ must be occupied at the conclusion of $\bm{m}$
\item if $\bm{s}$ is initially occupied, $\bm{g}$ must be unoccupied at the conclusion of $\bm{m}$ 
\end{enumerate}
By Theorem \ref{thm:AdditionalRobotsCannotPreventAnOccupation}, if $\bm{s}$ initially unoccupied results in $\bm{g}$ being occupied by some robot $r$ at the conclusion of $\bm{m}$, then the addition of a robot $q$ at $s$ cannot prevent $g$ from being filled, resulting in a contradiction.
\end{proof}

This shows that dual-rail logic is necessary for the formation of {\sc not} gates. 

Additionally, we show that $1\times1$ robots are insufficient to produce fan-out gates. To this end, we must examine the possibilities both when we add additional robots to the scenario, as well as when we remove robots.  

\begin{theorem}\label{thm:TwoRobotsTwoGoalsImpliesOneRobotOneGoal} 
If given a workspace $W$ and a command sequence $\bm{m}$ that moves two robots, $r_1$ and $r_2$, initially at $\bm{s}_1$ and $\bm{s}_2$, to respective goal locations $\bm{g}_1$ and $\bm{g}_2$, then removing one robot results in either $\bm{g}_1$ or $\bm{g}_2$ being occupied at the conclusion of $\bm{m}$.
\end{theorem}

\begin{proof} 
Without loss of generality, robot $r_1$ is removed. 

First suppose $r_2$ never hits $r_1$. Then the removal of $r_1$ will not affect the path of $r_2$. Robot $r_2$ has the same number of hits that it had before the removal of $r_1$ and so by Lemma \ref{lemma:changeInHitsNeededToChangePath}, $r_2$ will follow the same path and occupy $\bm{g}_2$ at the conclusion. 

Alternatively, suppose $r_2$ hit $r_1$ when $r_1$ was occupying location $\bm{x}$. Because $r_1$ is removed, it no longer occupies $\bm{x}$ during this move; because it was stopped in the common direction when being hit by $r_2$, robot $r_2$ gets stopped by this obstacle at location $\bm{x}$, previously occupied by $r_1$. $r_2$ now proceeds along the path previously traveled by $r_1$. Effectively, $r_2$ has replaced $r_1$ and follows the path until it reaches $\bm{g}_1$. Successive hits between $r_2$ and $r_1$ in the original scenario are resolved in the same manner.
\end{proof}

\begin{corollary}\label{cor:No1x1FanOut}
A  conservative dual-logic {\sc fan-out} gate cannot be constructed using only 1$\times$1 robots.
\end{corollary}

  \begin{table}
\begin{displaymath}
\begin{array}{ccc|cccc}
%\toprule
\multicolumn{3}{c}{\emph{Inputs}} & \multicolumn{4}{c}{\emph{Outputs}} \\
%\cmidrule(r){1-3}
   A & \overline{A} & 1 & A & A &  \overline{A} & \overline{A}\\
\hline
0 & 1 & 1 & 0 & 0 & 1 & 1  \\
1 & 0 & 1 & 1 & 1 & 0 & 0  \\
%\bottomrule
\end{array}
\end{displaymath}
\caption{{\sc fan-out} operation. This cannot be implemented with 1$\times$1 particles and obstacles. Our technique uses 2$\times$1 particles. }
  \label{tab:Fanout}
\end{table}

%\textcolor{red}{I think we have all the pieces here, but we need to say something about it being conservative. That is a key piece of our argument here. }
%\textcolor{blue}{Why does conservative matter?  We've already said we are using dual-rail logic.  The big problem here is that we cannot create copies of an input}

\begin{proof} We assume such a {\sc fan-out} gate exists and reach a contradiction. 
Consider a  {\sc fan-out} gate $W$,  dual-rail input locations  $\bm{s}_{a}$, $\bm{s}_{\overline{a}}$, and dual-rail output locations  $\{\bm{g}_{a_1}, \bm{g}_{a_2},\bm{g}_{\overline{a}_1},\bm{g}_{\overline{a}_2}\}$. Because particle logic is conservative there must also be one additional input location $\bm{s}_r$ and robot $r$. A {\sc fan-out} gate implements the truth table shown in Table \ref{tab:Fanout}. Given an arbitrary command sequence $\bm{m}$:  
\begin{enumerate}
\item if $\bm{s}_{a}$  and $\bm{s}_r$ are initially occupied and $\bm{s}_{\overline{a}}$ vacant, at the conclusion of $\bm{m}$ then $\bm{g}_{a_1}$ and $\bm{g}_{a_2}$ are occupied and the locations  $\bm{g}_{\overline{a}_1}$ and $\bm{g}_{\overline{a}_2}$ are vacant.
\item if $\bm{s}_{a}$ is initially vacant and $\bm{s}_{\overline{a}}$ and $\bm{s}_r$ are occupied, at the conclusion of $\bm{m}$ then $g_{a_1}$ and $g_{a_2}$ are vacant and the locations  $g_{\overline{a}_1}$ and $g_{\overline{a}_2}$ are occupied.
\end{enumerate}

We will now assume that condition 1, above, is the original scenario and  add and subtract robots, applying theorems~\ref{thm:AdditionalRobotsCannotPreventAnOccupation} and~\ref{thm:TwoRobotsTwoGoalsImpliesOneRobotOneGoal}, to show that it is impossible to meet condition 2. 

Assume condition 1. Robots $a$ and $r$ start at $\bm{s}_{a}$ and $\bm{s}_r$  respectively and at the conclusion of $\bm{m}$, the locations  $\bm{g}_{a1}$ and $\bm{g}_{a2}$ are occupied. Now remove robot $a$. According to  Thm.~\ref{thm:TwoRobotsTwoGoalsImpliesOneRobotOneGoal}, either $\bm{g}_{a_1}$ or $\bm{g}_{a_2}$ must be occupied at the conclusion of $\bm{m}$. Suppose without loss of generality that $\bm{g}_{a_1}$ is filled.  By Thm.~\ref{thm:AdditionalRobotsCannotPreventAnOccupation}, adding an additional robot at location $s_{\overline{a}}$ cannot prevent $\bm{g}_{a_1}$ from being filled. However, to meet condition 2, $\bm{g}_{a_1}$ must be vacant, thus no such gate is possible. 
 \end{proof}

%\begin{table}
%\begin{displaymath}
%\begin{array}{cc|cccccc}
%\toprule
%   A & B & A\lor{}B & AB & \overline{A\lor{}B} & \overline{AB} & A\oplus B & \overline{A\oplus B} \\
%\midrule
%0 & 0 & 0 & 0 & 1 & 1 & 0 & 1 \\
%0 & 1 & 1 & 0 & 0 & 1 & 1 & 0 \\
%1 & 0 & 1 & 0 & 0 & 1 & 1 & 0 \\
%1 & 1 & 1 & 1 & 0 & 0 & 0 & 1 \\
%\bottomrule
%\end{array}
%\end{displaymath}
%  \caption{Implemented Boolean operations in dual-rail particle logic.}
%  \label{tab:dualRailParticleLogic}
%\end{table}

%###############################################################  
\section{Device and gate design}\label{sec:Design}
%###############################################################  
This section describes how the clock signal, logic gates, and wiring were designed.
\subsection{Choosing a clock signal}

The \emph{clock sequence} is the ordered set of moves that are simultaneously applied to every particle in our workspace. We call this the clock sequence because, as in digital computers, this sequence is universally applied and keeps all logic synchronized.

A clock sequence determines the basic functionality of each gate.  To simplify implementation in the spirit of Reduced Instruction Set Computing (RISC), which uses a simplified set of instructions that run at the same rate, we want to use the same clock cycle for each gate and for \emph{all} wiring. 
Our early work used a standard sequence  $\langle d,l,d,r \rangle$.  This sequence can be used to make {\sc and, or, xor}, and any of their inverses.  This sequence can also be used for \emph{wiring} to connect arbitrary inputs and outputs, as long as the outputs are below the inputs.  Unfortunately, $\langle d,l,d,r \rangle$ cannot move any particles upwards. To connect outputs as inputs to higher-level logic requires an additional reset sequence that contains a $\langle u \rangle$ command.  Therefore, including all four directions is a necessary condition for a valid clock sequence.  The shortest sequence has four commands, each appearing once. We choose the sequence, $\langle d,l,u,r \rangle$, and by designing examples prove that this sequence is sufficient for logic gates, {\sc fan-out} gates, and wiring.

  
%  A clock sequence without orthogonal inputs, i.e. $\langle u,d,u,d \rangle$ can only implement assertions.  \textcolor{red}{This is an assertion. You need to support it} Using two orthogonal inputs, i.e.~$\langle d,l,d,l \rangle$  cannot implement {\sc fan-out} gates,\textcolor{red}{another assertion} and particles cannot be returned $u$ or $r$.  Therefore, including all four directions is a necessary condition for a valid clock sequence.  We choose the simplest such sequence, $\langle d,l,u,r \rangle$, and prove that this  sequence is sufficient for logic gates, {\sc fan-out} gates, and wiring. \textcolor{red}{Here's what I got out of this paragraph: In order to simplify our system and according the principles of RISC we would like to use the same clock sequence for all gates. This sequence should also be used for all wiring, that is for all connections between inputs and outputs. It is insufficient to use a clock sequence with only two directions. If these two directions are orthogonal (i.e. d,l,d,l) it is insufficient because (need more explanation here). If these two directions are not orthogonal (i.e. d,u,d,u) it is insufficient because (need more explanation here). Using only three directions, we were able to implement AND, OR, and  XOR gates, as well as their inverses. Specifically, in our previous work we used the sequence d,l,d,r. However this sequence makes it impossible to wire outputs of gates to inputs of gates that are higher up in the workspace. As clock sequences with two and three directions are insufficient for our purposes we have chosen to the simplest sequence d,l,u,r and will proceed to prove that this sequence is sufficient for logic gates, fan-out gates, and wiring.  }

This clock sequence has the attractive property of being a clockwise (CW) rotation through the possible input sequences.  One could imagine our particle logic circuit mounted on a wheel rotating about an axis parallel to the ground. If the particles were moved by the pull of gravity, each counter-clockwise revolution would advance the circuit by one clock cycle.

\subsection{A {\sc fan-out} Gate}\label{sec:FanOut}
A {\sc fan-out} gate with two outputs implements the truth table in Table~\ref{tab:Fanout}.  
This cannot be implemented with 1$\times$1 particles and obstacles, by corollary \ref{cor:No1x1FanOut}.   Our technique uses 2$\times$1 particles.   A single-input, two-output {\sc fan-out} gate is shown in Fig~\ref{fig:Fanout}.  This gate requires a dual-rail input, a supply particle, and a $2\times 1$ slider.  The  \emph{clockwise} control sequence $\langle d,l,u,r \rangle$  duplicates the dual-rail input.

The {\sc fan-out} gate can drive multiple outputs. In Fig.~\ref{fig:Fanout4} a single input drives four outputs.  This gate requires a dual-rail input, three supply particles, and a $2\times 1$ slider.  The \emph{clockwise} control sequence $\langle d,l,u,r \rangle$ quadruples the dual-rail input.
In general, an $n$-output {\sc fan-out} gate with control sequence $\langle d,l,u,r \rangle$ requires a dual-rail input, $n-1$ supply particles, and one $2\times 1$ slider. It requires an area of size $4 (n+1) \times 2(n+1)$.
  
 \begin{figure}
 \vspace{1em}
\begin{overpic}[width =\columnwidth]{FanOutS1cw.png}
\put(6.75,25){$A$} \put(15,25){$1$} \put(35,25){$\overline{A}$}
\put(62.5,25){$A$} \put(70,25){$1$} \put(90,25){$\overline{A}$}

\put(17.5,0){$A$}\put(24,0){$A$} \put(31.2,0){$\overline{A}$} \put(38,0){$\overline{A}$} 
\put(72.5,0){$A$} \put(79.5,0){$A$} \put(86.2,0){$\overline{A}$} \put(93,0){$\overline{A}$} 
\put(0,-5){ $\langle d \rangle$}\put(20,-5){$A=0$ }\put(70,-5){ $A=1$ }\end{overpic}\\
\vspace{-.5em}\\

\begin{overpic}[width =\columnwidth]{FanOutS2cw.png}\put(0,-5){ $\langle d,l \rangle$}\put(20,-5){$A=0$ }\put(70,-5){ $A=1$ }\end{overpic}\\
\vspace{-.5em}\\

\begin{overpic}[width =\columnwidth]{FanOutS4cw.png}\put(0,-5){ $\langle d,l,d,r \rangle$}\put(20,-5){$A=0$ }\put(70,-5){ $A=1$ }
\put(17.5,0){$A$}\put(24,0){$A$} \put(31.2,0){$\overline{A}$} \put(38,0){$\overline{A}$} 
\put(72.5,0){$A$} \put(79.5,0){$A$} \put(86.2,0){$\overline{A}$} \put(93,0){$\overline{A}$} 
\end{overpic}
\caption{
\label{fig:Fanout}
A single input, two-output {\sc fan-out} gate.  This gate requires a dual-rail input, a supply particle, and a $2\times 1$ slider.  The  \emph{clockwise} control sequence $\langle d,l,u,r \rangle$  duplicates the dual-rail input.
}
\vspace{-1em}
\end{figure}

 \begin{figure} 
 \vspace{2em}
\begin{overpic}[width =\columnwidth]{FanOutcw4step12.png}
\put(2,-7){ $\langle d, l \rangle$}
\put(20,-7){$A=0$ }\put(70,-7){ $A=1$ }
\scriptsize
\put(9,21){$1$~~$1$~~$1$~~\,$A$} \put(41,21){$\overline{A}$} 
\put(61.2,21){$1$~~$1$~~$1$~~\,$A$} \put(93.5,21){$\overline{A}$} 

\put(10,-3){$A$~\,\,$A$~\,$A$~\,$A$} \put(30.5,-3){$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$} 
\put(63,-3){$A$~\,\,$A$~\,$A$~\,$A$} \put(83.6,-3){$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$} 
\end{overpic}\\
\vspace{.5em}\\

\begin{overpic}[width =\columnwidth]{FanOutcw4step34.png}
\put(2,-7){ $\langle d,l,u,r \rangle$}
\put(20,-7){$A=0$ }\put(70,-7){ $A=1$ }
\scriptsize
\put(9,21){$1$~~$1$~~$1$~~\,$A$} \put(41,21){$\overline{A}$} 
\put(61.2,21){$1$~~$1$~~$1$~~\,$A$} \put(93.5,21){$\overline{A}$} 

\put(10,-3){$A$~\,\,$A$~\,$A$~\,$A$} \put(30.5,-3){$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$} 
\put(63,-3){$A$~\,\,$A$~\,$A$~\,$A$} \put(83.6,-3){$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$~\,$\overline{A}$} 
\end{overpic}
\caption{\label{fig:Fanout4}
The {\sc fan-out} gate can drive multiple outputs. Here a single input drives four outputs.  This gate requires a dual-rail input, three supply particles, and a $2\times 1$ slider.  The \emph{clockwise} control sequence $\langle d,l,u,r \rangle$ quadruples the dual-rail input.
}
\vspace{-1em}
\end{figure}

\subsection{Data Storage\label{subsec:Storage}}

A general-purpose computer must be able to store data.  A $2\times1$ particle enables us to construct a read/writable data storage for one bit. A single-bit data storage latch is shown in Fig.~\ref{fig:Memory} and implements the truth table in Table \ref{tab:memoryTruthTable}.     By combining an $n$-out {\sc fan-out} gate shown in Fig~\ref{fig:Fanout4} with $n$ data storage devices, we can implement an $n$-bit memory. To maintain \emph{conservative} properties of the computer, i.e., the same number of robots enter and leave each gate,  single-bit data storage latches must be used in pairs to record the state and its inverse.

 \begin{figure*}
\begin{overpic}[width =2\columnwidth]{MemoryElement.pdf}
\end{overpic}
\caption{\label{fig:Memory}
A flip-flop memory.  This device has three inputs, \emph{Read}, \emph{Set}, \emph{Clear}, a state variable (shown in blue), and a $2\times 1$ slider.  Depending on which input is active, the \emph{clockwise} control sequence $\langle d,l,u,r \rangle$ will read, set, or clear the memory.
}
\end{figure*}

\begin{table}
\begin{displaymath}
\begin{array}{cccc|ccccc}
\toprule
   Q
 & R
 & S
 & C
 & Q
 & Q_R
 & W_1
 & W_2
 & \overline{Q}_R \\
\midrule
0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 1\\
0 & 0 & 1 & 0 & 1 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0\\
1 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0\\
1 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1\\
1 & 0 & 0 & 1 & 0 & 0 & 1 & 1 & 0\\
\bottomrule
\end{array}
\end{displaymath}
  \caption{A single-bit data storage latch with state $Q$.  \label{tab:memoryTruthTable}}
\end{table}
  
\subsection{A Binary Counter}\label{sec:binaryCounter}
  Using the {\sc fan-out} gate from Section \ref{sec:FanOut} we can generate arbitrary Boolean logic.  The half-adder from Fig.~\ref{fig:HalfAdder} requires a single {\sc fan-out} gate, one {\sc and} and one {\sc xor} gate.
  
We illustrate how several gates can be combined by constructing a binary counter, shown in Fig.~\ref{fig:Counter}. Six logic gates are used to implement a 3-bit counter. A block diagram of the device is shown in Fig.~\ref{fig:CounterBlockDiagram}. The counter  requires three {\sc fan-out} gates, two adders, and one carry. Six $1\times1$ particles and three $2\times1$ particles are used.  The counter has three levels of gates $\langle d,l,d,r \rangle$ and requires three interconnection moves $\langle d,l,d,r \rangle$, for a total of 24 moves per cycle. 
%Figure \ref{fig:CounterShowingEachStage} shows the ending configuration for each iteration of the counter.

\begin{figure}\centering
 \begin{overpic}[width =.8\columnwidth]{BinCounterCW000.png}\end{overpic}
\vspace{-1em}\\
\caption{
\label{fig:Counter}
A three-bit counter implemented with particles. The counter  requires three {\sc fan-out} gates, two summers, and one carry.  Six 1$\times$1 particles and three 2$\times$1 particles are used.  The counter has three levels of gates actuated by CW sequence $\langle d,l,u,r \rangle$ and requires three interconnection sequences $\langle d,l,u,r \rangle$, for a total of 24 moves. See video attachment for animation.
}
\end{figure}


 \begin{figure}
 \begin{overpic}[width =\columnwidth]{counterSchem.pdf}\end{overpic}
\caption{
\label{fig:CounterBlockDiagram}
Gate-level diagram for an $n$-bit counter.  The counter requires $n-1$ {\sc xor} gates, $n-2$ {\sc and} gates, and 1 {\sc not} gate.
}
\vspace{-1em}
\end{figure}

%     \begin{figure*}
% \begin{overpic}[width =0.49\columnwidth]{BinCounterCW000.png}\put(20,-6){$b_2b_1b_0=000$}\end{overpic}
%  \begin{overpic}[width =0.49\columnwidth]{BinCounterCW001.png}\put(20,-6){$b_2b_1b_0=001$}\end{overpic}
%   \begin{overpic}[width =0.49\columnwidth]{BinCounterCW010.png}\put(20,-6){$b_2b_1b_0=010$}\end{overpic}
%    \begin{overpic}[width =0.49\columnwidth]{BinCounterCW011.png}\put(20,-6){$b_2b_1b_0=011$}\end{overpic}\\
%    \vspace{0.1em}\\
%     \begin{overpic}[width =0.49\columnwidth]{BinCounterCW100.png}\put(20,-6){$b_2b_1b_0=100$}\end{overpic}
%      \begin{overpic}[width =0.49\columnwidth]{BinCounterCW101.png}\put(20,-6){$b_2b_1b_0=101$}\end{overpic}
%       \begin{overpic}[width =0.49\columnwidth]{BinCounterCW110.png}\put(20,-6){$b_2b_1b_0=110$}\end{overpic}
%        \begin{overpic}[width =0.49\columnwidth]{BinCounterCW111.png}\put(20,-6){$b_2b_1b_0=111$}\end{overpic}
%\vspace{.1em}\\
%\caption{
%\label{fig:CounterShowingEachStage}
%Ending configuration for each stage of the computation.
%}
%\vspace{-1em}
%\end{figure*}


\subsection{Scaling Issues}\setcounter{paragraph}{0}
 Particle computation requires multiple clock cycles, workspace area for gates and interconnections, and many particles.  In this section we analyze how these scale with the size of the counter, using Fig.~\ref{fig:CounterBlockDiagram} as a reference.   

%n+n-1+n-2 = 3(n-1)

\paragraph{gates}  an $n$-bit counter requires $3(n-1)$ gates: $n$ {\sc fan-out} gates, $n-1$ summers ({\sc xor}) gates, and $n-2$ carry ({\sc and}) gates. 
\paragraph{particles} we require $n$ 1$\times$1 particles, one for each bit and $n$ 2$\times$1 particles, one for each {\sc fan-out} gate.
\paragraph{ propagation delay} the counter requires $n$ stages of logic, and $n$ corresponding wiring stages.  Each stage requires a complete clock cycle $\langle d,l,u,r \rangle$ for a total of 8$n$ moves.

%http://en.wikipedia.org/wiki/Adder_(electronics)  one FA needs 5 gates 2 XOR, 2 AND 1 OR,  Half after needs 2gates: 1 XOR, 1 AND, n-bit ripple needs 5(n-1)+2 gates
These requirements are comparable to a ripple-carry adder:  the delay for $n$ bits is $n$ delays  and requires $5(n-1)+2$ gates.
Numerous other schemes exist to speed up the computation; however, using discrete gates allows us to use standard methods for translating a Boolean expression into gate-level logic.  If speed was critical, instead of using discrete gates, we could engineer the workspace to directly compute the desired logic.  

\subsection{Optimal Wiring Schemes}\label{sec:wiring}
With our current CW clock cycle, we cannot have outputs from the same column as
inputs---outputs must be either one to the right, or three to the left.  
Choosing one of these results in horizontal shifts at each stage and thus
requires spreading out the logic gates. A better wiring scheme cycles
through three layers that each shift right by one, followed by one layer that
shifts left by three.  We also want the wiring to be tight left-to-right.  If our
height is also limited, \emph{wire buses}, shown in Fig.~\ref{fig:Counter} provide a compact solution. 

%###############################################################
\section{Experiment}\label{sec:Experiment}
%###############################################################
A large-scale prototype was built as a physical implementation of particle computation with global inputs, shown in Fig.~\ref{fig:prototype}.  The design is inspired by the gravity-fed logic maze \emph{Tilt\texttrademark}
\url{http://www.thinkfun.com/tilt}. Figure~\ref{fig:MultiFanOutPhysical} shows a functioning single-input, four-output {\sc fan-out} gate.  The left column replicates an $A$ input, and the right column an $\overline{A}$, both represented by a red 1$\times$1 particle.  The gate requires three  1$\times$1 supply particles, shown in blue.  The slider is white and the obstacles are yellow.  %See Fig.~\ref{fig:Scale} for construction details.
The video attachment demonstrates how the gates are constructed and shows each variant in operation.

The experimental setup consists of Plexiglas square boards, which can be assembled together to form a bigger board. Each board has 12 vertical and 12 horizontal slots that constitute a checkered board. Each slot is 5mm in width and 4mm in depth.  The distance between adjacent slots is 20mm. Different configurations can be achieved using 19mm$\times$19mm obstacles, which can be fitted in any slot junction. A clearance of 0.5mm on each side of the obstacle ensures that moving parts can slide past.  There are two types of moving parts; 1$\times$1 and 1$\times$2 sliders. 1$\times$1 sliders are 19.5mm diameter steel cylinders.  Beneath this top cylinder is a cylindrical peg with a diameter of 4mm that guides the slider through the slot. 1$\times$2 sliders are 20mm$\times$40mm rectangular steel parts with a rectangular guide at the bottom.

The board can rotate along two perpendicular axes and these rotations generate the four valid commands. Both types of sliders start moving at 12.5$^\circ$. Experimental data on success rate as a function of tipping angle are shown in Fig.~\ref{fig:TipAngleExperiment}. We chose a rotation of 20$^\circ$ for each command to ensure that sliders  slide reliably.

%  \begin{table}
%\begin{displaymath}
%\begin{array}{r c c c c c | c c c c c}
%%\toprule
%& \multicolumn{5}{c}{1$\times$1 slider} & \multicolumn{5}{c}{1$\times$2 slider	} \\
%\hline
%rotation angle (degree)	&12	&13	&14	&15		&20	&12	&13	&14	&15	&20 \\
%failures per 50 tests		&10	&1	&3	&0		&0	&6	&8	&0	&0	&0 \\
%success rate (percent)	&80	&98	&94	&100	&100	&88	&84	&100	&100	&100
%%\bottomrule
%\end{array}
%\end{displaymath}
%\caption{Reliability as a function of rotation angle}
%  \label{tab:Reliability}
%\end{table}


 \begin{figure}
\begin{overpic}[width =\columnwidth]{ReliabilityAsFuncTipAngle}\end{overpic}
\caption{\label{fig:TipAngleExperiment}Experimental data on slider reliability as a function of tip angle.}
\vspace{-1em}
\end{figure}

 \begin{figure}
% DSC_0003lr.JPG
%DSC_0006lr.JPG
%DSC_0009lr.JPG
%DSC_0010lr.JPG
%DSC_0013lr.JPG
%DSC_0015lr.JPG
% 
% DSC_0012lr.JPG
%DSC_0017lr.JPG
%DSC_0021lr.JPG
%DSC_0024lr.JPG
%DSC_0026lr.JPG
%DSC_0030lr.JPG
\begin{overpic}[width =0.49\columnwidth]{DSC_0003lr.JPG}\put(25,25){\textcolor{white}{start}}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0012lr.JPG}\end{overpic}\vspace{0.5em}\\
\begin{overpic}[width =0.49\columnwidth]{DSC_0006lr.JPG}\put(25,25){\textcolor{white}{$\downarrow$}}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0017lr.JPG}\end{overpic}\vspace{0.5em}\\
\begin{overpic}[width =0.49\columnwidth]{DSC_0009lr.JPG}\put(25,25){\textcolor{white}{$\leftarrow$}}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0021lr.JPG}\end{overpic}\vspace{0.5em}\\
\begin{overpic}[width =0.49\columnwidth]{DSC_0010lr.JPG}\put(25,25){\textcolor{white}{$\uparrow$}}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0024lr.JPG}\end{overpic}\vspace{0.5em}\\
\begin{overpic}[width =0.49\columnwidth]{DSC_0013lr.JPG}\put(25,25){\textcolor{white}{$\rightarrow$}}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0026lr.JPG}\end{overpic}\vspace{0.5em}\\
\begin{overpic}[width =0.49\columnwidth]{DSC_0015lr.JPG}\put(25,25){\textcolor{white}{end}}\put(30,-8){$A=1$}\end{overpic}
\begin{overpic}[width =0.49\columnwidth]{DSC_0030lr.JPG}\put(30,-8){$A=0$}\end{overpic}\\
\caption{\label{fig:MultiFanOutPhysical}Implementation of a single-input, four-output {\sc fan-out} gate.  See video attachment at \url{http://youtu.be/EJSv8ny31r8}.}
\vspace{-1em}
\end{figure}

% \begin{figure}
%\begin{overpic}[width =\columnwidth]{scale.JPG}\end{overpic}
%\caption{\label{fig:Scale}Detail of the prototype construction.}
%\vspace{-1em}
%\end{figure}

%###############################################################
\section{Conclusion}\label{sec:Conclusion}
%###############################################################
In this paper we 
(1) proved the insufficiency of unit-size particles for gate fan-out; 
(2) established the necessity of dual-rail logic for Boolean logic;  
(3) designed {\sc fan-out} gates and memory latches by employing slightly different particles;
 (4) presented an architecture for device integration,  a common clock sequence, and a binary counter,
 and (5) implemented a large-scale prototype of particle computation.

This work, along with \cite{Becker2013f,Becker2014,Becker2014a}, introduces a
new model for mechanical computation.  Interesting applications will aim at 
nanoscale and microfluidics work.

    
%\section{Acknowledgements}
%This work was supported by the National Science Foundation under
%\href{http://nsf.gov/awardsearch/showAward?AWD_ID=1208509}{NRI-1208509}.  
   
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../../RoboticSwarmControlLab/bib/aaronrefs}%
%\bibliography{IEEEabrv,../../../svn/ensemble/bib/aaronrefs}%,../aaronrefs} %../../../../../../ensemble/bib/aaronrefs}

\end{document}


